/*
* Copyright (c) 2019, Andreas Madsen
* All rights reserved.
*
* Cephes is LICENSED with special permision under BSD.
* Copyright (c) 2019, Steven Moshier
* All rights reserved.
*
*/
!function(n,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-core"],e):e((n=n||self).tfspecial=n.tfspecial||{},n.tf)}(this,function(n,e){"use strict";var a=function(n,e){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var a in e)e.hasOwnProperty(a)&&(n[a]=e[a])})(n,e)};function t(n,e){function t(){this.constructor=n}a(n,e),n.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)}function r(n){var e="function"==typeof Symbol&&n[Symbol.iterator],a=0;return e?e.call(n):{next:function(){return n&&a>=n.length&&(n=void 0),{value:n&&n[a++],done:!n}}}}function f(n,e){var a="function"==typeof Symbol&&n[Symbol.iterator];if(!a)return n;var t,r,f=a.call(n),l=[];try{for(;(void 0===e||e-- >0)&&!(t=f.next()).done;)l.push(t.value)}catch(n){r={error:n}}finally{try{t&&!t.done&&(a=f.return)&&a.call(f)}finally{if(r)throw r.error}}return l}function l(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(f(arguments[e]));return n}var o=new(function(){function n(){this.constants=new Map,this.variables=new Map,this.functions=new Map}return n.prototype.add=function(n){switch(n.kernelType){case"Constant":this.constants.set(n.name,n);break;case"Variable":this.variables.set(n.name,n);break;case"Function":this.functions.set(n.name,n);break;default:throw new Error("unreachable")}},n.prototype.getSignature=function(n){if(!this.functions.has(n))throw new Error("function "+n+" is not declared");return this.functions.get(n).signature},n.prototype.getUsedSymbols=function(n){var e=this.getKernelParts(n),a=e.usedConstants,t=e.usedVariables,r=e.usedFunctions;return new Set(l(a.keys(),t.keys(),r.keys()))},n.prototype.exportAsWebGL=function(n,e){return 2===e?this.exportAs(n,"WebGL2"):this.exportAs(n,"WebGL1")},n.prototype.exportAsJS=function(n){return this.exportAs(n,"JS")},n.prototype.getKernelParts=function(n){var e,a,t,f,l,o;if(!this.functions.has(n))throw new Error("function "+n+" is not declared");for(var i=new Map,x=new Map,s=new Map,m=[this.functions.get(n)];m.length>0;){var u=m.pop();if(!s.has(u.name)){s.set(u.name,u);try{for(var p=r(u.constants),c=p.next();!c.done;c=p.next()){var b=c.value;if(!this.constants.has(b))throw new Error("constant "+b+" used by "+u.name+" is not declared");i.set(b,this.constants.get(b))}}catch(n){e={error:n}}finally{try{c&&!c.done&&(a=p.return)&&a.call(p)}finally{if(e)throw e.error}}try{for(var g=r(u.variables),d=g.next();!d.done;d=g.next()){var y=d.value;if(!this.variables.has(y))throw new Error("variable "+y+" used by "+u.name+" is not declared");x.set(y,this.variables.get(y))}}catch(n){t={error:n}}finally{try{d&&!d.done&&(f=g.return)&&f.call(g)}finally{if(t)throw t.error}}try{for(var k=r(u.dependencies),h=k.next();!h.done;h=k.next()){var v=h.value;if(!this.functions.has(v))throw new Error("function "+v+" used by "+u.name+" is not declared");s.has(v)||m.push(this.functions.get(v))}}catch(n){l={error:n}}finally{try{h&&!h.done&&(o=k.return)&&o.call(k)}finally{if(l)throw l.error}}}}return{usedConstants:i,usedVariables:x,usedFunctions:s}},n.prototype.exportUniforms=function(n){var e,a,t,f,l=this.getKernelParts(n),o=l.usedConstants,i=l.usedVariables,x=new Map;try{for(var s=r(o.values()),m=s.next();!m.done;m=s.next()){(c=m.value).value instanceof Float32Array&&x.set(c.name,c.value)}}catch(n){e={error:n}}finally{try{m&&!m.done&&(a=s.return)&&a.call(s)}finally{if(e)throw e.error}}try{for(var u=r(i.values()),p=u.next();!p.done;p=u.next()){var c;(c=p.value).value instanceof Float32Array&&x.set(c.name,c.value)}}catch(n){t={error:n}}finally{try{p&&!p.done&&(f=u.return)&&f.call(u)}finally{if(t)throw t.error}}return x},n.prototype.exportResetAs=function(n,e){var a=this.getKernelParts(n).usedVariables;return Array.from(a.values()).map(function(n){return n.exportResetAs(e)}).join("\n")},n.prototype.exportAs=function(n,e){var a=this.getKernelParts(n),t=a.usedConstants,r=a.usedVariables,f=a.usedFunctions;return["// compiled kernel for "+n,"","//","// constant declarations","//",Array.from(t.values()).map(function(n){return n.exportAs(e)}).join("\n"),"","//","// global variable declarations :(","//",Array.from(r.values()).map(function(n){return n.exportAs(e)}).join("\n"),"","//","// function signatures","//",Array.from(f.values()).map(function(n){return n.exportSignatureAs(e)}).filter(function(n){return null!==n}).join("\n"),"","//","// function declarations","//",Array.from(f.values()).map(function(n){return n.exportAs(e)}).filter(function(n){return null!==n}).join("\n\n"),""].join("\n")},n}()),i=function(n){this.name=n};function x(){for(var n,e,a=[],t=0;t<arguments.length;t++)a[t]=arguments[t];var f=[];if(1===a.length)return a[0];try{for(var o=r(a),i=o.next();!i.done;i=o.next())for(var x=i.value,m=x.length-1,u=f.length-1;m>=0;m--,u--)if(u<0)f.unshift(x[m]);else if(1===x[m]);else if(1===f[u])f[u]=x[m];else if(x[m]!==f[u])throw s.apply(void 0,l(a))}catch(e){n={error:e}}finally{try{i&&!i.done&&(e=o.return)&&e.call(o)}finally{if(n)throw n.error}}return f}function s(){for(var n=[],e=0;e<arguments.length;e++)n[e]=arguments[e];var a=n.slice(0,-1).map(function(n){return JSON.stringify(n)}).join(", "),t=JSON.stringify(n[n.length-1]);return new Error("Operands could not be broadcast together with shapes "+a+" and "+t+".")}function m(n,a,t){for(var f=n.map(function(n){return e.buffer(n.shape,n.dtype,n.dataSync())}),o=f.map(function(n){return n.values}),i=x.apply(void 0,l(n.map(function(n){return n.shape}))),s=e.buffer(i,a),m=s.values,u=n.map(function(n){return e.backend_util.getBroadcastDims(n.shape,i)}),p=function(e){var a=s.indexToLoc(e),i=n.map(function(n,e){var t,l,i=a.slice(-n.rank);try{for(var x=r(u[e]),s=x.next();!s.done;s=x.next()){i[s.value]=0}}catch(n){t={error:n}}finally{try{s&&!s.done&&(l=x.return)&&l.call(x)}finally{if(t)throw t.error}}var m=f[e].locToIndex(i);return o[e][m]});m[e]=t.apply(void 0,l(i))},c=0;c<m.length;++c)p(c);return s.toTensor()}var u=function(n){function a(e){var a=n.call(this,e)||this,t=o.getSignature(e),r=t.arguments.map(function(n){return n.name}).join(", "),f=o.exportResetAs(e,"JS"),l="\n            'strict mode';\n\n            const NAN = Number.NaN;\n            const INFINITY = Number.Infinity;\n\n            "+o.exportAsJS(e)+"\n\n            function main("+r+") {\n                // Reset global variables\n                "+f+"\n\n                // run function\n                return "+t.name+"("+r+");\n            }\n\n            return main;\n        ";return a.program=new Function(l)(),a}return t(a,n),a.prototype.run=function(){for(var n=[],e=0;e<arguments.length;e++)n[e]=arguments[e];return m(n,"float32",this.program)},a.prototype.runUnary=function(n){for(var a=e.buffer(n.shape,n.dtype,n.dataSync()).values,t=e.buffer(n.shape,"float32"),r=t.values,f=0;f<r.length;++f)r[f]=this.program(a[f]);return t.toTensor()},a}(i),p=function(n,e,a){this.outputShape=n,this.variableNames=e,this.userCode=a},c=function(n){function a(e,a){var t,l,i,x,s=n.call(this,e)||this;if(s.version=a,s.uniforms=new Map,s.version<2)try{for(var m=r(o.exportUniforms(e)),u=m.next();!u.done;u=m.next()){var p=f(u.value,2),c=p[0],b=p[1];s.uniforms.set(c,{value:b,loc:new Map})}}catch(n){t={error:n}}finally{try{u&&!u.done&&(l=m.return)&&l.call(m)}finally{if(t)throw t.error}}var g=o.getSignature(e);s.variableNames=g.arguments.map(function(n){return"V"+n.index});var d=[];try{for(var y=r(g.arguments),k=y.next();!k.done;k=y.next()){var h=k.value;d.push(h.type+" "+h.name+" = getV"+h.index+"AtOutCoords();")}}catch(n){i={error:n}}finally{try{k&&!k.done&&(x=y.return)&&x.call(y)}finally{if(i)throw i.error}}return d.push("float value = "+g.name+"("+g.arguments.map(function(n){return n.name}).join(",")+");"),d.push("setOutput(value);"),s.source="\n            "+o.exportAsWebGL(e,a)+"\n\n            void main() {\n                "+d.join("                \n")+"\n            }\n        ",s}return t(a,n),a.prototype.makeProgramLocKey=function(n,e){return l(n.map(function(n){return n.shape.join(",")}),[e.join(",")]).join("|")},a.prototype.customSetup=function(n,e,a){var t,l;try{for(var o=r(this.uniforms.entries()),i=o.next();!i.done;i=o.next()){var x=f(i.value,2),s=x[0],m=x[1],u=m.loc,p=m.value,c=u.get(n);c=e.getUniformLocation(a,s,!1),u.set(n,c),e.gl.uniform1fv(c,p)}}catch(n){t={error:n}}finally{try{i&&!i.done&&(l=o.return)&&l.call(o)}finally{if(t)throw t.error}}},a.prototype.compileAndRun=function(n,a){var t=this,r=new p(a,this.variableNames,this.source),f=e.backend();return this.version<2?f.compileAndRun(r,n,null,function(e,r){return t.customSetup(t.makeProgramLocKey(n,a),e,r)}):f.compileAndRun(r,n)},a.prototype.run=function(){for(var n=[],e=0;e<arguments.length;e++)n[e]=arguments[e];var a=x.apply(void 0,l(n.map(function(n){return n.shape})));return this.compileAndRun(n,a)},a.prototype.runUnary=function(n){return this.compileAndRun([n],n.shape)},a}(i),b=[new Map,new Map,new Map];function g(n,a){void 0===a&&(a=null),null===a&&(a="cpu"===e.getBackend()?0:e.ENV.getNumber("WEBGL_VERSION"));var t=b[a].get(n);return void 0===t&&(t=a>0?new c(n,a):new u(n),b[a].set(n,t)),t}var d,y,k=function(){function n(){}return n.prototype.exportAs=function(n){switch(n){case"WebGL1":return this.exportAsWebGL(1);case"WebGL2":return this.exportAsWebGL(2);case"JS":return this.exportAsJS();default:throw new Error("unreachable")}},n}(),h=function(n){function e(e){var a=n.call(this)||this;return a.name=e.name,a.type=e.type,a.value=e.value,a.valueString=e.valueString,a}return t(e,n),e}(k),v=function(n){function e(e){var a=n.call(this,e)||this;return a.kernelType="Constant",a}return t(e,n),e.prototype.exportAsWebGL=function(n){return this.value instanceof Float32Array?2===n?"float "+this.name+"["+this.value.length+"] = float[]("+this.valueString+");":"uniform float "+this.name+"["+this.value.length+"];":"const "+this.type+" "+this.name+" = "+this.valueString+";"},e.prototype.exportAsJS=function(){return this.value instanceof Float32Array?"const "+this.name+" = new Float32Array(["+this.valueString+"]);":"const "+this.name+" = "+this.valueString+";"},e}(h),_=function(n){function e(e){var a=n.call(this,e)||this;return a.kernelType="Variable",a}return t(e,n),e.prototype.exportResetAs=function(n){switch(n){case"WebGL1":return this.exportResetAsWebGL(1);case"WebGL2":return this.exportResetAsWebGL(2);case"JS":return this.exportResetAsJS();default:throw new Error("unreachable")}},e.prototype.exportResetAsWebGL=function(n){return"// WebGL does not need resetting of "+this.name},e.prototype.exportResetAsJS=function(){if(this.value instanceof Float32Array)throw new Error("can not reset "+this.name);return this.name+" = "+this.valueString+";"},e.prototype.exportAsWebGL=function(n){return this.value instanceof Float32Array?2===n?"float "+this.name+"["+this.value.length+"] = float[]("+this.valueString+");":"uniform float "+this.name+"["+this.value.length+"];":this.type+" "+this.name+" = "+this.valueString+";"},e.prototype.exportAsJS=function(){return this.value instanceof Float32Array?"let "+this.name+" = new Float32Array(["+this.valueString+"]);":"let "+this.name+" = "+this.valueString+";"},e}(h),q=function(n){function e(e){var a=n.call(this)||this;return a.name=e.name,a.type=e.type,a.index=e.index,a}return t(e,n),e.prototype.exportAsWebGL=function(n){var e=this.type.indexOf("[");return-1!==e?this.type.slice(0,e)+" "+this.name+this.type.slice(e):this.type+" "+this.name},e.prototype.exportAsJS=function(){return""+this.name},e}(k),A=function(n){function e(e){var a=n.call(this)||this;return a.name=e.name,a.type=e.type,a.arguments=e.arguments.map(function(n){return new q(n)}),a}return t(e,n),e.prototype.exportAsWebGL=function(n){var e=this.arguments.map(function(e){return e.exportAsWebGL(n)}).join(", ");return this.type+" "+this.name+"("+e+")"},e.prototype.exportAsJS=function(){var n=this.arguments.map(function(n){return n.exportAsJS()}).join(", ");return"function "+this.name+"("+n+")"},e}(k),z=function(n){function e(e){var a=n.call(this)||this;return a.kernelType="Function",a.dependencies=e.dependencies,a.constants=e.constants,a.variables=e.variables,a.signature=new A(e.signature),a.codeWebGL=e.codeWebGL,a.codeJS=e.codeJS,a}return t(e,n),Object.defineProperty(e.prototype,"name",{get:function(){return this.signature.name},enumerable:!0,configurable:!0}),e.prototype.exportSignatureAs=function(n){switch(n){case"WebGL1":return this.exportSignatureAsWebGL(1);case"WebGL2":return this.exportSignatureAsWebGL(2);case"JS":return this.exportSignatureAsJS();default:throw new Error("unreachable")}},e.prototype.exportSignatureAsWebGL=function(n){return null===this.codeWebGL?null:this.signature.exportAsWebGL(n)+";"},e.prototype.exportSignatureAsJS=function(){return null===this.codeJS?null:"//"+this.signature.exportAsJS()},e.prototype.exportAsWebGL=function(n){return null===this.codeWebGL?null:this.codeWebGL},e.prototype.exportAsJS=function(){return null===this.codeJS?null:this.codeJS},e}(k);o.add(new z({dependencies:["floor","mtherr","float","lgamf","exp","gammaf"],constants:["MAXNUMF","MAXLOGF"],variables:["sgngamf"],signature:{name:"betaf",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"bb",type:"float",index:1}]},codeWebGL:"float betaf(float aa, float bb) {\n  float a;\n  float b;\n  float y;\n  int sign;\n  sign = 1;\n  a = aa;\n  b = bb;\n  if ((a <= 0.0)) {\n    if ((a == floor(a))) {\n      mtherr(3);\n      return (float(sign) * MAXNUMF);\n    }\n  }\n  if ((b <= 0.0)) {\n    if ((b == floor(b))) {\n      mtherr(3);\n      return (float(sign) * MAXNUMF);\n    }\n  }\n  y = (a + b);\n  if ((((y < float(0)) ? -y : y) > 34.84425627277176174)) {\n    y = lgamf(y);\n    sign *= sgngamf;\n    y = (lgamf(b) - y);\n    sign *= sgngamf;\n    y = (lgamf(a) + y);\n    sign *= sgngamf;\n    if ((y > MAXLOGF)) {\n      mtherr(3);\n      return (float(sign) * MAXNUMF);\n    }\n    return (float(sign) * exp(y));\n  }\n  y = gammaf(y);\n  if ((y == 0.0)) {\n    mtherr(3);\n    return (float(sign) * MAXNUMF);\n  }\n  if ((a > b)) {\n    y = (gammaf(a) / y);\n    y *= gammaf(b);\n  } else {\n    y = (gammaf(b) / y);\n    y *= gammaf(a);\n  }\n  return y;\n}",codeJS:"function betaf(aa, bb) {\n  let a;\n  let b;\n  let y;\n  let sign;\n  sign = 1;\n  a = aa;\n  b = bb;\n  if ((a <= 0.0)) {\n    if ((a === floor(a))) {\n      mtherr(3);\n      return (float(sign) * MAXNUMF);\n    }\n  }\n  if ((b <= 0.0)) {\n    if ((b === floor(b))) {\n      mtherr(3);\n      return (float(sign) * MAXNUMF);\n    }\n  }\n  y = (a + b);\n  if ((((y < float(0)) ? -y : y) > 34.84425627277176174)) {\n    y = lgamf(y);\n    sign *= sgngamf;\n    y = (lgamf(b) - y);\n    sign *= sgngamf;\n    y = (lgamf(a) + y);\n    sign *= sgngamf;\n    if ((y > MAXLOGF)) {\n      mtherr(3);\n      return (float(sign) * MAXNUMF);\n    }\n    return (float(sign) * exp(y));\n  }\n  y = gammaf(y);\n  if ((y === 0.0)) {\n    mtherr(3);\n    return (float(sign) * MAXNUMF);\n  }\n  if ((a > b)) {\n    y = (gammaf(a) / y);\n    y *= gammaf(b);\n  } else {\n    y = (gammaf(b) / y);\n    y *= gammaf(a);\n  }\n  return y;\n}"})),o.add(new v({name:"MAXNUMF",type:"float",value:34028234663852886e22,valueString:"3.4028234663852885981170418348451692544e38"})),o.add(new v({name:"MAXLOGF",type:"float",value:88.72283905206835,valueString:"88.72283905206835"})),o.add(new v({name:"PIF",type:"float",value:3.141592653589793,valueString:"3.141592653589793238"})),o.add(new v({name:"MACHEPF",type:"float",value:5.960464477539063e-8,valueString:"5.9604644775390625E-8"})),o.add(new v({name:"gammaf_STIR",type:"float",value:new Float32Array([-.002705194986674176,.00347325578615491,.08333331788340907]),valueString:"-2.705194986674176E-003, 3.473255786154910E-003, 8.333331788340907E-002"})),o.add(new v({name:"gammaf_MAXSTIR",type:"float",value:26.77,valueString:"26.77"})),o.add(new v({name:"gammaf_SQTPIF",type:"float",value:2.5066282746310007,valueString:"2.50662827463100050242"})),o.add(new _({name:"sgngamf",type:"int",value:0,valueString:"0"})),o.add(new z({dependencies:["polevlf_3","exp","pow"],constants:["gammaf_STIR","gammaf_MAXSTIR","gammaf_SQTPIF"],variables:[],signature:{name:"gammaf_stirf",type:"float",arguments:[{name:"xx",type:"float",index:0}]},codeWebGL:"float gammaf_stirf(float xx) {\n  float x;\n  float y;\n  float w;\n  float v;\n  x = xx;\n  w = (1.0 / x);\n  w = (1.0 + (w * polevlf_3(w, gammaf_STIR, 2)));\n  y = exp(-x);\n  if ((x > gammaf_MAXSTIR)) {\n    v = pow(x, ((0.5 * x) - 0.25));\n    y *= v;\n    y *= v;\n  } else {\n    y = (pow(x, (x - 0.5)) * y);\n  }\n  y = ((gammaf_SQTPIF * y) * w);\n  return y;\n}",codeJS:"function gammaf_stirf(xx) {\n  let x;\n  let y;\n  let w;\n  let v;\n  x = xx;\n  w = (1.0 / x);\n  w = (1.0 + (w * polevlf_3(w, gammaf_STIR, 2)));\n  y = exp(-x);\n  if ((x > gammaf_MAXSTIR)) {\n    v = pow(x, ((0.5 * x) - 0.25));\n    y *= v;\n    y *= v;\n  } else {\n    y = (pow(x, (x - 0.5)) * y);\n  }\n  y = ((gammaf_SQTPIF * y) * w);\n  return y;\n}"})),o.add(new v({name:"gammaf_P",type:"float",value:new Float32Array([.001536830450601906,.005397581592950993,.004130370201859976,.07232307985516519,.08203960091619193,.4117857447645796,.4227867745131584,.9999999822945073]),valueString:"1.536830450601906E-003, 5.397581592950993E-003, 4.130370201859976E-003, 7.232307985516519E-002, 8.203960091619193E-002, 4.117857447645796E-001, 4.227867745131584E-001, 9.999999822945073E-001"})),o.add(new z({dependencies:["floor","mtherr","float","int","is_odd","sin","gammaf_stirf","bool","polevlf_8"],constants:["MAXNUMF","PIF","gammaf_P"],variables:["sgngamf"],signature:{name:"gammaf",type:"float",arguments:[{name:"xx",type:"float",index:0}]},codeWebGL:"float gammaf(float xx) {\n  float p;\n  float q;\n  float x;\n  float z;\n  float nz;\n  int i;\n  int direction;\n  int negative;\n  x = xx;\n  sgngamf = 1;\n  negative = 0;\n  nz = 0.0;\n  if ((x < 0.0)) {\n    negative = 1;\n    q = -x;\n    p = floor(q);\n    if ((p == q)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    i = int(p);\n    if ((is_odd(i) == 0)) sgngamf = -1;\n    nz = (q - p);\n    if ((nz > 0.5)) {\n      p += 1.0;\n      nz = (q - p);\n    }\n    nz = (q * sin((PIF * nz)));\n    if ((nz == 0.0)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    if ((nz < float(0))) nz = -nz;\n    x = q;\n  }\n  if ((x >= 10.0)) {\n    z = gammaf_stirf(x);\n  }\n  if ((x < 2.0)) direction = 1; else direction = 0;\n  z = 1.0;\n  for (int while_i = 0; (while_i < 1000); while_i++) {\n    if (!(x >= 3.0)) break;\n    x -= 1.0;\n    z *= x;\n  }\n  \n  for (int while_j = 0; (while_j < 1000); while_j++) {\n    if (!(x < 2.0)) break;\n    if ((x < 1.e-4)) {\n      if ((x == 0.0)) {\n        mtherr(2);\n        return MAXNUMF;\n      } else {\n        p = (z / ((1.0 + (0.5772156649015329 * x)) * x));\n        if (bool(negative)) {\n          p = ((float(sgngamf) * PIF) / (nz * p));\n        }\n        return p;\n      }\n    }\n    z *= x;\n    x += 1.0;\n  }\n  \n  if (bool(direction)) z = (1.0 / z);\n  if ((x == 2.0)) return z;\n  x -= 2.0;\n  p = (z * polevlf_8(x, gammaf_P, 7));\n  if (bool(negative)) {\n    p = ((float(sgngamf) * PIF) / (nz * p));\n  }\n  return p;\n  if ((x == 0.0)) {\n    mtherr(2);\n    return MAXNUMF;\n  } else {\n    p = (z / ((1.0 + (0.5772156649015329 * x)) * x));\n    if (bool(negative)) {\n      p = ((float(sgngamf) * PIF) / (nz * p));\n    }\n    return p;\n  }\n}",codeJS:"function gammaf(xx) {\n  let p;\n  let q;\n  let x;\n  let z;\n  let nz;\n  let i;\n  let direction;\n  let negative;\n  x = xx;\n  sgngamf = 1;\n  negative = 0;\n  nz = 0.0;\n  if ((x < 0.0)) {\n    negative = 1;\n    q = -x;\n    p = floor(q);\n    if ((p === q)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    i = int(p);\n    if ((is_odd(i) === 0)) sgngamf = -1;\n    nz = (q - p);\n    if ((nz > 0.5)) {\n      p += 1.0;\n      nz = (q - p);\n    }\n    nz = (q * sin((PIF * nz)));\n    if ((nz === 0.0)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    if ((nz < float(0))) nz = -nz;\n    x = q;\n  }\n  if ((x >= 10.0)) {\n    z = gammaf_stirf(x);\n  }\n  if ((x < 2.0)) direction = 1; else direction = 0;\n  z = 1.0;\n  for (let while_i = 0; (while_i < 1000); while_i++) {\n    if (!(x >= 3.0)) break;\n    x -= 1.0;\n    z *= x;\n  }\n  \n  for (let while_j = 0; (while_j < 1000); while_j++) {\n    if (!(x < 2.0)) break;\n    if ((x < 1.e-4)) {\n      if ((x === 0.0)) {\n        mtherr(2);\n        return MAXNUMF;\n      } else {\n        p = (z / ((1.0 + (0.5772156649015329 * x)) * x));\n        if (bool(negative)) {\n          p = ((float(sgngamf) * PIF) / (nz * p));\n        }\n        return p;\n      }\n    }\n    z *= x;\n    x += 1.0;\n  }\n  \n  if (bool(direction)) z = (1.0 / z);\n  if ((x === 2.0)) return z;\n  x -= 2.0;\n  p = (z * polevlf_8(x, gammaf_P, 7));\n  if (bool(negative)) {\n    p = ((float(sgngamf) * PIF) / (nz * p));\n  }\n  return p;\n  if ((x === 0.0)) {\n    mtherr(2);\n    return MAXNUMF;\n  } else {\n    p = (z / ((1.0 + (0.5772156649015329 * x)) * x));\n    if (bool(negative)) {\n      p = ((float(sgngamf) * PIF) / (nz * p));\n    }\n    return p;\n  }\n}"})),o.add(new v({name:"gammaf_B",type:"float",value:new Float32Array([.0006055172732649237,-.001311620815545743,.002863437556468661,-.007366775108654962,.02058355474821512,-.06735323259371034,.3224669577325661,.4227843421859038]),valueString:"6.055172732649237E-004, -1.311620815545743E-003, 2.863437556468661E-003, -7.366775108654962E-003, 2.058355474821512E-002, -6.735323259371034E-002, 3.224669577325661E-001, 4.227843421859038E-001"})),o.add(new v({name:"gammaf_C",type:"float",value:new Float32Array([.1369488127325832,-.1590086327657347,.1692415923504637,-.2067882815621965,.2705806208275915,-.4006931650563372,.8224670749082976,-.5772156501719101]),valueString:"1.369488127325832E-001, -1.590086327657347E-001, 1.692415923504637E-001, -2.067882815621965E-001, 2.705806208275915E-001, -4.006931650563372E-001, 8.224670749082976E-001, -5.772156501719101E-001"})),o.add(new v({name:"gammaf_LS2PI",type:"float",value:.9189385332046728,valueString:"0.91893853320467274178"})),o.add(new v({name:"gammaf_PIINV",type:"float",value:.3183098861837907,valueString:"0.318309886183790671538"})),o.add(new z({dependencies:["lgamf_recusive_lgamf","floor","mtherr","float","int","is_odd","sin","log","polevlf_8","bool"],constants:["MAXNUMF","PIF","gammaf_PIINV","gammaf_B","gammaf_C","gammaf_LS2PI"],variables:["sgngamf"],signature:{name:"lgamf",type:"float",arguments:[{name:"xx",type:"float",index:0}]},codeWebGL:"float lgamf(float xx) {\n  float p;\n  float q;\n  float w;\n  float z;\n  float x;\n  float nx;\n  float tx;\n  int i;\n  int direction;\n  sgngamf = 1;\n  x = xx;\n  if ((x < 0.0)) {\n    q = -x;\n    w = lgamf_recusive_lgamf(q);\n    p = floor(q);\n    if ((p == q)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    i = int(p);\n    if ((is_odd(i) == 0)) sgngamf = -1; else sgngamf = 1;\n    z = (q - p);\n    if ((z > 0.5)) {\n      p += 1.0;\n      z = (p - q);\n    }\n    z = (q * sin((PIF * z)));\n    if ((z == 0.0)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    z = (-log((gammaf_PIINV * z)) - w);\n    return z;\n  }\n  if ((x < 6.5)) {\n    direction = 0;\n    z = 1.0;\n    tx = x;\n    nx = 0.0;\n    if ((x >= 1.5)) {\n      for (int while_k = 0; (while_k < 1000); while_k++) {\n        if (!(tx > 2.5)) break;\n        nx -= 1.0;\n        tx = (x + nx);\n        z *= tx;\n      }\n      \n      x += (nx - 2.0);\n      p = (x * polevlf_8(x, gammaf_B, 7));\n      if ((z < 0.0)) {\n        sgngamf = -1;\n        z = -z;\n      } else {\n        sgngamf = 1;\n      }\n      q = log(z);\n      if (bool(direction)) q = -q;\n      return (p + q);\n    }\n    if ((x >= 1.25)) {\n      z *= x;\n      x -= 1.0;\n      direction = 1;\n      p = (x * polevlf_8(x, gammaf_B, 7));\n      if ((z < 0.0)) {\n        sgngamf = -1;\n        z = -z;\n      } else {\n        sgngamf = 1;\n      }\n      q = log(z);\n      if (bool(direction)) q = -q;\n      return (p + q);\n    }\n    if ((x >= 0.75)) {\n      x -= 1.0;\n      p = (x * polevlf_8(x, gammaf_C, 7));\n      q = 0.0;\n      return (p + q);\n    }\n    for (int while_a = 0; (while_a < 1000); while_a++) {\n      if (!(tx < 1.5)) break;\n      if ((tx == 0.0)) {\n        mtherr(3);\n        return (float(sgngamf) * MAXNUMF);\n      }\n      z *= tx;\n      nx += 1.0;\n      tx = (x + nx);\n    }\n    \n    direction = 1;\n    x += (nx - 2.0);\n    p = (x * polevlf_8(x, gammaf_B, 7));\n    if ((z < 0.0)) {\n      sgngamf = -1;\n      z = -z;\n    } else {\n      sgngamf = 1;\n    }\n    q = log(z);\n    if (bool(direction)) q = -q;\n    return (p + q);\n  }\n  if ((x > 2.035093e36)) {\n    mtherr(3);\n    return (float(sgngamf) * MAXNUMF);\n  }\n  q = (gammaf_LS2PI - x);\n  q += ((x - 0.5) * log(x));\n  if ((x <= 1.0e4)) {\n    z = (1.0 / x);\n    p = (z * z);\n    q += (((((6.789774945028216E-004 * p) - 2.769887652139868E-003) * p) + 8.333316229807355E-002) * z);\n  }\n  return q;\n}",codeJS:"function lgamf(xx) {\n  let p;\n  let q;\n  let w;\n  let z;\n  let x;\n  let nx;\n  let tx;\n  let i;\n  let direction;\n  sgngamf = 1;\n  x = xx;\n  if ((x < 0.0)) {\n    q = -x;\n    w = lgamf_recusive_lgamf(q);\n    p = floor(q);\n    if ((p === q)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    i = int(p);\n    if ((is_odd(i) === 0)) sgngamf = -1; else sgngamf = 1;\n    z = (q - p);\n    if ((z > 0.5)) {\n      p += 1.0;\n      z = (p - q);\n    }\n    z = (q * sin((PIF * z)));\n    if ((z === 0.0)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    z = (-log((gammaf_PIINV * z)) - w);\n    return z;\n  }\n  if ((x < 6.5)) {\n    direction = 0;\n    z = 1.0;\n    tx = x;\n    nx = 0.0;\n    if ((x >= 1.5)) {\n      for (let while_k = 0; (while_k < 1000); while_k++) {\n        if (!(tx > 2.5)) break;\n        nx -= 1.0;\n        tx = (x + nx);\n        z *= tx;\n      }\n      \n      x += (nx - 2.0);\n      p = (x * polevlf_8(x, gammaf_B, 7));\n      if ((z < 0.0)) {\n        sgngamf = -1;\n        z = -z;\n      } else {\n        sgngamf = 1;\n      }\n      q = log(z);\n      if (bool(direction)) q = -q;\n      return (p + q);\n    }\n    if ((x >= 1.25)) {\n      z *= x;\n      x -= 1.0;\n      direction = 1;\n      p = (x * polevlf_8(x, gammaf_B, 7));\n      if ((z < 0.0)) {\n        sgngamf = -1;\n        z = -z;\n      } else {\n        sgngamf = 1;\n      }\n      q = log(z);\n      if (bool(direction)) q = -q;\n      return (p + q);\n    }\n    if ((x >= 0.75)) {\n      x -= 1.0;\n      p = (x * polevlf_8(x, gammaf_C, 7));\n      q = 0.0;\n      return (p + q);\n    }\n    for (let while_a = 0; (while_a < 1000); while_a++) {\n      if (!(tx < 1.5)) break;\n      if ((tx === 0.0)) {\n        mtherr(3);\n        return (float(sgngamf) * MAXNUMF);\n      }\n      z *= tx;\n      nx += 1.0;\n      tx = (x + nx);\n    }\n    \n    direction = 1;\n    x += (nx - 2.0);\n    p = (x * polevlf_8(x, gammaf_B, 7));\n    if ((z < 0.0)) {\n      sgngamf = -1;\n      z = -z;\n    } else {\n      sgngamf = 1;\n    }\n    q = log(z);\n    if (bool(direction)) q = -q;\n    return (p + q);\n  }\n  if ((x > 2.035093e36)) {\n    mtherr(3);\n    return (float(sgngamf) * MAXNUMF);\n  }\n  q = (gammaf_LS2PI - x);\n  q += ((x - 0.5) * log(x));\n  if ((x <= 1.0e4)) {\n    z = (1.0 / x);\n    p = (z * z);\n    q += (((((6.789774945028216E-004 * p) - 2.769887652139868E-003) * p) + 8.333316229807355E-002) * z);\n  }\n  return q;\n}"})),o.add(new z({dependencies:["floor","mtherr","float","int","is_odd","sin","log","polevlf_8","bool"],constants:["MAXNUMF","PIF","gammaf_PIINV","gammaf_B","gammaf_C","gammaf_LS2PI"],variables:["sgngamf"],signature:{name:"lgamf_recusive_lgamf",type:"float",arguments:[{name:"xx",type:"float",index:0}]},codeWebGL:"float lgamf_recusive_lgamf(float xx) {\n  float p;\n  float q;\n  float w;\n  float z;\n  float x;\n  float nx;\n  float tx;\n  int i;\n  int direction;\n  sgngamf = 1;\n  x = xx;\n  if ((x < 0.0)) {\n    q = -x;\n    w = NAN;\n    p = floor(q);\n    if ((p == q)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    i = int(p);\n    if ((is_odd(i) == 0)) sgngamf = -1; else sgngamf = 1;\n    z = (q - p);\n    if ((z > 0.5)) {\n      p += 1.0;\n      z = (p - q);\n    }\n    z = (q * sin((PIF * z)));\n    if ((z == 0.0)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    z = (-log((gammaf_PIINV * z)) - w);\n    return z;\n  }\n  if ((x < 6.5)) {\n    direction = 0;\n    z = 1.0;\n    tx = x;\n    nx = 0.0;\n    if ((x >= 1.5)) {\n      for (int while_b = 0; (while_b < 1000); while_b++) {\n        if (!(tx > 2.5)) break;\n        nx -= 1.0;\n        tx = (x + nx);\n        z *= tx;\n      }\n      \n      x += (nx - 2.0);\n      p = (x * polevlf_8(x, gammaf_B, 7));\n      if ((z < 0.0)) {\n        sgngamf = -1;\n        z = -z;\n      } else {\n        sgngamf = 1;\n      }\n      q = log(z);\n      if (bool(direction)) q = -q;\n      return (p + q);\n    }\n    if ((x >= 1.25)) {\n      z *= x;\n      x -= 1.0;\n      direction = 1;\n      p = (x * polevlf_8(x, gammaf_B, 7));\n      if ((z < 0.0)) {\n        sgngamf = -1;\n        z = -z;\n      } else {\n        sgngamf = 1;\n      }\n      q = log(z);\n      if (bool(direction)) q = -q;\n      return (p + q);\n    }\n    if ((x >= 0.75)) {\n      x -= 1.0;\n      p = (x * polevlf_8(x, gammaf_C, 7));\n      q = 0.0;\n      return (p + q);\n    }\n    for (int while_c = 0; (while_c < 1000); while_c++) {\n      if (!(tx < 1.5)) break;\n      if ((tx == 0.0)) {\n        mtherr(3);\n        return (float(sgngamf) * MAXNUMF);\n      }\n      z *= tx;\n      nx += 1.0;\n      tx = (x + nx);\n    }\n    \n    direction = 1;\n    x += (nx - 2.0);\n    p = (x * polevlf_8(x, gammaf_B, 7));\n    if ((z < 0.0)) {\n      sgngamf = -1;\n      z = -z;\n    } else {\n      sgngamf = 1;\n    }\n    q = log(z);\n    if (bool(direction)) q = -q;\n    return (p + q);\n  }\n  if ((x > 2.035093e36)) {\n    mtherr(3);\n    return (float(sgngamf) * MAXNUMF);\n  }\n  q = (gammaf_LS2PI - x);\n  q += ((x - 0.5) * log(x));\n  if ((x <= 1.0e4)) {\n    z = (1.0 / x);\n    p = (z * z);\n    q += (((((6.789774945028216E-004 * p) - 2.769887652139868E-003) * p) + 8.333316229807355E-002) * z);\n  }\n  return q;\n}",codeJS:"function lgamf_recusive_lgamf(xx) {\n  let p;\n  let q;\n  let w;\n  let z;\n  let x;\n  let nx;\n  let tx;\n  let i;\n  let direction;\n  sgngamf = 1;\n  x = xx;\n  if ((x < 0.0)) {\n    q = -x;\n    w = NAN;\n    p = floor(q);\n    if ((p === q)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    i = int(p);\n    if ((is_odd(i) === 0)) sgngamf = -1; else sgngamf = 1;\n    z = (q - p);\n    if ((z > 0.5)) {\n      p += 1.0;\n      z = (p - q);\n    }\n    z = (q * sin((PIF * z)));\n    if ((z === 0.0)) {\n      mtherr(3);\n      return (float(sgngamf) * MAXNUMF);\n    }\n    z = (-log((gammaf_PIINV * z)) - w);\n    return z;\n  }\n  if ((x < 6.5)) {\n    direction = 0;\n    z = 1.0;\n    tx = x;\n    nx = 0.0;\n    if ((x >= 1.5)) {\n      for (let while_b = 0; (while_b < 1000); while_b++) {\n        if (!(tx > 2.5)) break;\n        nx -= 1.0;\n        tx = (x + nx);\n        z *= tx;\n      }\n      \n      x += (nx - 2.0);\n      p = (x * polevlf_8(x, gammaf_B, 7));\n      if ((z < 0.0)) {\n        sgngamf = -1;\n        z = -z;\n      } else {\n        sgngamf = 1;\n      }\n      q = log(z);\n      if (bool(direction)) q = -q;\n      return (p + q);\n    }\n    if ((x >= 1.25)) {\n      z *= x;\n      x -= 1.0;\n      direction = 1;\n      p = (x * polevlf_8(x, gammaf_B, 7));\n      if ((z < 0.0)) {\n        sgngamf = -1;\n        z = -z;\n      } else {\n        sgngamf = 1;\n      }\n      q = log(z);\n      if (bool(direction)) q = -q;\n      return (p + q);\n    }\n    if ((x >= 0.75)) {\n      x -= 1.0;\n      p = (x * polevlf_8(x, gammaf_C, 7));\n      q = 0.0;\n      return (p + q);\n    }\n    for (let while_c = 0; (while_c < 1000); while_c++) {\n      if (!(tx < 1.5)) break;\n      if ((tx === 0.0)) {\n        mtherr(3);\n        return (float(sgngamf) * MAXNUMF);\n      }\n      z *= tx;\n      nx += 1.0;\n      tx = (x + nx);\n    }\n    \n    direction = 1;\n    x += (nx - 2.0);\n    p = (x * polevlf_8(x, gammaf_B, 7));\n    if ((z < 0.0)) {\n      sgngamf = -1;\n      z = -z;\n    } else {\n      sgngamf = 1;\n    }\n    q = log(z);\n    if (bool(direction)) q = -q;\n    return (p + q);\n  }\n  if ((x > 2.035093e36)) {\n    mtherr(3);\n    return (float(sgngamf) * MAXNUMF);\n  }\n  q = (gammaf_LS2PI - x);\n  q += ((x - 0.5) * log(x));\n  if ((x <= 1.0e4)) {\n    z = (1.0 / x);\n    p = (z * z);\n    q += (((((6.789774945028216E-004 * p) - 2.769887652139868E-003) * p) + 8.333316229807355E-002) * z);\n  }\n  return q;\n}"})),o.add(new z({dependencies:["float","exp","hypergf_recusive_hypergf","hypergf_hy1f1pf","mtherr","hypergf_hy1f1af"],constants:[],variables:[],signature:{name:"hypergf",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"bb",type:"float",index:1},{name:"xx",type:"float",index:2}]},codeWebGL:"float hypergf(float aa, float bb, float xx) {\n  // func call multiple return is not used in WebGL;\n  float a;\n  float b;\n  float x;\n  float asum;\n  float psum;\n  float acanc;\n  float pcanc;\n  float temp;\n  a = aa;\n  b = bb;\n  x = xx;\n  temp = (b - a);\n  if ((((temp < float(0)) ? -temp : temp) < (0.001 * ((a < float(0)) ? -a : a)))) return (exp(x) * hypergf_recusive_hypergf(temp, b, -x));\n  psum = hypergf_hy1f1pf(a, b, x, pcanc);\n  if ((pcanc < 1.0e-6)) {\n    if ((pcanc > 1.0e-3)) mtherr(6);\n    return psum;\n  }\n  asum = hypergf_hy1f1af(a, b, x, acanc);\n  if ((acanc < pcanc)) {\n    pcanc = acanc;\n    psum = asum;\n  }\n  if ((pcanc > 1.0e-3)) mtherr(6);\n  return psum;\n}",codeJS:"function hypergf(aa, bb, xx) {\n  let _mainReturn = NaN;\n  let a;\n  let b;\n  let x;\n  let asum;\n  let psum;\n  let acanc;\n  let pcanc;\n  let temp;\n  a = aa;\n  b = bb;\n  x = xx;\n  temp = (b - a);\n  if ((((temp < float(0)) ? -temp : temp) < (0.001 * ((a < float(0)) ? -a : a)))) return (exp(x) * hypergf_recusive_hypergf(temp, b, -x));\n  psum = ([_mainReturn, pcanc] = hypergf_hy1f1pf(a, b, x, pcanc), _mainReturn);\n  if ((pcanc < 1.0e-6)) {\n    if ((pcanc > 1.0e-3)) mtherr(6);\n    return psum;\n  }\n  asum = ([_mainReturn, acanc] = hypergf_hy1f1af(a, b, x, acanc), _mainReturn);\n  if ((acanc < pcanc)) {\n    pcanc = acanc;\n    psum = asum;\n  }\n  if ((pcanc > 1.0e-3)) mtherr(6);\n  return psum;\n}"})),o.add(new z({dependencies:["float","mtherr"],constants:["MACHEPF","MAXNUMF"],variables:[],signature:{name:"hypergf_hy1f1pf",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"bb",type:"float",index:1},{name:"xx",type:"float",index:2},{name:"err",type:"inout float",index:3}]},codeWebGL:"float hypergf_hy1f1pf(float aa, float bb, float xx, inout float err) {\n  float a;\n  float b;\n  float x;\n  float n;\n  float a0;\n  float sum;\n  float t;\n  float u;\n  float temp;\n  float an;\n  float bn;\n  float maxt;\n  float pcanc;\n  a = aa;\n  b = bb;\n  x = xx;\n  an = a;\n  bn = b;\n  a0 = 1.0;\n  sum = 1.0;\n  n = 1.0;\n  t = 1.0;\n  maxt = 0.0;\n  for (int while_i = 0; (while_i < 1000); while_i++) {\n    if (!(t > MACHEPF)) break;\n    if ((bn == float(0))) {\n      mtherr(2);\n      return MAXNUMF;\n    }\n    if ((an == float(0))) return sum;\n    if ((n > float(200))) {\n      if ((sum != 0.0)) maxt /= ((sum < float(0)) ? -sum : sum);\n      maxt *= MACHEPF;\n      pcanc = ((((MACHEPF * n) + maxt) < float(0)) ? -((MACHEPF * n) + maxt) : ((MACHEPF * n) + maxt));\n      err = pcanc;\n      return sum;\n    }\n    u = (x * (an / (bn * n)));\n    temp = ((u < float(0)) ? -u : u);\n    if (((temp > 1.0) && (maxt > (MAXNUMF / temp)))) {\n      pcanc = 1.0;\n      err = pcanc;\n      return sum;\n    }\n    a0 *= u;\n    sum += a0;\n    t = ((a0 < float(0)) ? -a0 : a0);\n    if ((t > maxt)) maxt = t;\n    an += 1.0;\n    bn += 1.0;\n    n += 1.0;\n  }\n  \n  if ((sum != 0.0)) maxt /= ((sum < float(0)) ? -sum : sum);\n  maxt *= MACHEPF;\n  pcanc = ((((MACHEPF * n) + maxt) < float(0)) ? -((MACHEPF * n) + maxt) : ((MACHEPF * n) + maxt));\n  err = pcanc;\n  return sum;\n}",codeJS:"function hypergf_hy1f1pf(aa, bb, xx, err) {\n  let a;\n  let b;\n  let x;\n  let n;\n  let a0;\n  let sum;\n  let t;\n  let u;\n  let temp;\n  let an;\n  let bn;\n  let maxt;\n  let pcanc;\n  a = aa;\n  b = bb;\n  x = xx;\n  an = a;\n  bn = b;\n  a0 = 1.0;\n  sum = 1.0;\n  n = 1.0;\n  t = 1.0;\n  maxt = 0.0;\n  for (let while_i = 0; (while_i < 1000); while_i++) {\n    if (!(t > MACHEPF)) break;\n    if ((bn === float(0))) {\n      mtherr(2);\n      return [MAXNUMF, err];\n    }\n    if ((an === float(0))) return [sum, err];\n    if ((n > float(200))) {\n      if ((sum !== 0.0)) maxt /= ((sum < float(0)) ? -sum : sum);\n      maxt *= MACHEPF;\n      pcanc = ((((MACHEPF * n) + maxt) < float(0)) ? -((MACHEPF * n) + maxt) : ((MACHEPF * n) + maxt));\n      err = pcanc;\n      return [sum, err];\n    }\n    u = (x * (an / (bn * n)));\n    temp = ((u < float(0)) ? -u : u);\n    if (((temp > 1.0) && (maxt > (MAXNUMF / temp)))) {\n      pcanc = 1.0;\n      err = pcanc;\n      return [sum, err];\n    }\n    a0 *= u;\n    sum += a0;\n    t = ((a0 < float(0)) ? -a0 : a0);\n    if ((t > maxt)) maxt = t;\n    an += 1.0;\n    bn += 1.0;\n    n += 1.0;\n  }\n  \n  if ((sum !== 0.0)) maxt /= ((sum < float(0)) ? -sum : sum);\n  maxt *= MACHEPF;\n  pcanc = ((((MACHEPF * n) + maxt) < float(0)) ? -((MACHEPF * n) + maxt) : ((MACHEPF * n) + maxt));\n  err = pcanc;\n  return [sum, err];\n}"})),o.add(new z({dependencies:["float","log","lgamf","hyp2f0f","exp","gammaf"],constants:["MAXNUMF"],variables:[],signature:{name:"hypergf_hy1f1af",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"bb",type:"float",index:1},{name:"xx",type:"float",index:2},{name:"err",type:"inout float",index:3}]},codeWebGL:"float hypergf_hy1f1af(float aa, float bb, float xx, inout float err) {\n  // func call multiple return is not used in WebGL;\n  float a;\n  float b;\n  float x;\n  float h1;\n  float h2;\n  float t;\n  float u;\n  float temp;\n  float acanc;\n  float asum;\n  float err1;\n  float err2;\n  a = aa;\n  b = bb;\n  x = xx;\n  if ((x == float(0))) {\n    acanc = 1.0;\n    asum = MAXNUMF;\n    err = acanc;\n    return asum;\n  }\n  temp = log(((x < float(0)) ? -x : x));\n  t = (x + (temp * (a - b)));\n  u = (-temp * a);\n  if ((b > float(0))) {\n    temp = lgamf(b);\n    t += temp;\n    u += temp;\n  }\n  h1 = hyp2f0f(a, ((a - b) + float(1)), (-1.0 / x), 1, err1);\n  temp = (exp(u) / gammaf((b - a)));\n  h1 *= temp;\n  err1 *= temp;\n  h2 = hyp2f0f((b - a), (1.0 - a), (1.0 / x), 2, err2);\n  if ((a < float(0))) temp = (exp(t) / gammaf(a)); else temp = exp((t - lgamf(a)));\n  h2 *= temp;\n  err2 *= temp;\n  if ((x < 0.0)) asum = h1; else asum = h2;\n  acanc = (((err1 < float(0)) ? -err1 : err1) + ((err2 < float(0)) ? -err2 : err2));\n  if ((b < float(0))) {\n    temp = gammaf(b);\n    asum *= temp;\n    acanc *= ((temp < float(0)) ? -temp : temp);\n  }\n  if ((asum != 0.0)) acanc /= ((asum < float(0)) ? -asum : asum);\n  acanc *= 30.0;\n  err = acanc;\n  return asum;\n}",codeJS:"function hypergf_hy1f1af(aa, bb, xx, err) {\n  let _mainReturn = NaN;\n  let a;\n  let b;\n  let x;\n  let h1;\n  let h2;\n  let t;\n  let u;\n  let temp;\n  let acanc;\n  let asum;\n  let err1;\n  let err2;\n  a = aa;\n  b = bb;\n  x = xx;\n  if ((x === float(0))) {\n    acanc = 1.0;\n    asum = MAXNUMF;\n    err = acanc;\n    return [asum, err];\n  }\n  temp = log(((x < float(0)) ? -x : x));\n  t = (x + (temp * (a - b)));\n  u = (-temp * a);\n  if ((b > float(0))) {\n    temp = lgamf(b);\n    t += temp;\n    u += temp;\n  }\n  h1 = ([_mainReturn, err1] = hyp2f0f(a, ((a - b) + float(1)), (-1.0 / x), 1, err1), _mainReturn);\n  temp = (exp(u) / gammaf((b - a)));\n  h1 *= temp;\n  err1 *= temp;\n  h2 = ([_mainReturn, err2] = hyp2f0f((b - a), (1.0 - a), (1.0 / x), 2, err2), _mainReturn);\n  if ((a < float(0))) temp = (exp(t) / gammaf(a)); else temp = exp((t - lgamf(a)));\n  h2 *= temp;\n  err2 *= temp;\n  if ((x < 0.0)) asum = h1; else asum = h2;\n  acanc = (((err1 < float(0)) ? -err1 : err1) + ((err2 < float(0)) ? -err2 : err2));\n  if ((b < float(0))) {\n    temp = gammaf(b);\n    asum *= temp;\n    acanc *= ((temp < float(0)) ? -temp : temp);\n  }\n  if ((asum !== 0.0)) acanc /= ((asum < float(0)) ? -asum : asum);\n  acanc *= 30.0;\n  err = acanc;\n  return [asum, err];\n}"})),o.add(new z({dependencies:["float","mtherr"],constants:["MACHEPF","MAXNUMF"],variables:[],signature:{name:"hyp2f0f",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"bb",type:"float",index:1},{name:"xx",type:"float",index:2},{name:"type",type:"int",index:3},{name:"err",type:"inout float",index:4}]},codeWebGL:"float hyp2f0f(float aa, float bb, float xx, int type, inout float err) {\n  float a;\n  float b;\n  float x;\n  float a0;\n  float alast;\n  float t;\n  float tlast;\n  float maxt;\n  float n;\n  float an;\n  float bn;\n  float u;\n  float sum;\n  float temp;\n  a = aa;\n  b = bb;\n  x = xx;\n  an = a;\n  bn = b;\n  a0 = 1.0;\n  alast = 1.0;\n  sum = 0.0;\n  n = 1.0;\n  t = 1.0;\n  tlast = 1.0e9;\n  maxt = 0.0;\n  for (int dowhile_j = 0; (dowhile_j < 1000); dowhile_j++) {\n    if ((an == float(0))) {\n      err = (((MACHEPF * (n + maxt)) < float(0)) ? -(MACHEPF * (n + maxt)) : (MACHEPF * (n + maxt)));\n      alast = a0;\n      sum += alast;\n      return sum;\n      err = MAXNUMF;\n      mtherr(5);\n      return sum;\n      n -= 1.0;\n      x = (1.0 / x);\n      if ((type == 1)) {\n        alast *= (0.5 + (((((0.125 + (0.25 * b)) - (0.5 * a)) + (0.25 * x)) - (0.25 * n)) / x));\n      } else if ((type == 2)) {\n        alast *= (((((2.0 / 3.0) - b) + (2.0 * a)) + x) - n);\n      } else {\n        ;\n      }\n      err = ((MACHEPF * (n + maxt)) + ((a0 < float(0)) ? -a0 : a0));\n      sum += alast;\n      return sum;\n      err = MAXNUMF;\n      mtherr(5);\n      return sum;\n    }\n    if ((bn == float(0))) {\n      err = (((MACHEPF * (n + maxt)) < float(0)) ? -(MACHEPF * (n + maxt)) : (MACHEPF * (n + maxt)));\n      alast = a0;\n      sum += alast;\n      return sum;\n      err = MAXNUMF;\n      mtherr(5);\n      return sum;\n      n -= 1.0;\n      x = (1.0 / x);\n      if ((type == 1)) {\n        alast *= (0.5 + (((((0.125 + (0.25 * b)) - (0.5 * a)) + (0.25 * x)) - (0.25 * n)) / x));\n      } else if ((type == 2)) {\n        alast *= (((((2.0 / 3.0) - b) + (2.0 * a)) + x) - n);\n      } else {\n        ;\n      }\n      err = ((MACHEPF * (n + maxt)) + ((a0 < float(0)) ? -a0 : a0));\n      sum += alast;\n      return sum;\n      err = MAXNUMF;\n      mtherr(5);\n      return sum;\n    }\n    u = (an * ((bn * x) / n));\n    temp = ((u < float(0)) ? -u : u);\n    if (((temp > 1.0) && (maxt > (MAXNUMF / temp)))) {\n      err = MAXNUMF;\n      mtherr(5);\n      return sum;\n    }\n    a0 *= u;\n    t = ((a0 < float(0)) ? -a0 : a0);\n    if ((t > tlast)) {\n      n -= 1.0;\n      x = (1.0 / x);\n      if ((type == 1)) {\n        alast *= (0.5 + (((((0.125 + (0.25 * b)) - (0.5 * a)) + (0.25 * x)) - (0.25 * n)) / x));\n      } else if ((type == 2)) {\n        alast *= (((((2.0 / 3.0) - b) + (2.0 * a)) + x) - n);\n      } else {\n        ;\n      }\n      err = ((MACHEPF * (n + maxt)) + ((a0 < float(0)) ? -a0 : a0));\n      sum += alast;\n      return sum;\n      err = MAXNUMF;\n      mtherr(5);\n      return sum;\n    }\n    tlast = t;\n    sum += alast;\n    alast = a0;\n    if ((n > float(200))) {\n      n -= 1.0;\n      x = (1.0 / x);\n      if ((type == 1)) {\n        alast *= (0.5 + (((((0.125 + (0.25 * b)) - (0.5 * a)) + (0.25 * x)) - (0.25 * n)) / x));\n      } else if ((type == 2)) {\n        alast *= (((((2.0 / 3.0) - b) + (2.0 * a)) + x) - n);\n      } else {\n        ;\n      }\n      err = ((MACHEPF * (n + maxt)) + ((a0 < float(0)) ? -a0 : a0));\n      sum += alast;\n      return sum;\n      err = MAXNUMF;\n      mtherr(5);\n      return sum;\n    }\n    an += 1.0;\n    bn += 1.0;\n    n += 1.0;\n    if ((t > maxt)) maxt = t;\n    if (!(t > MACHEPF)) break;\n  }\n  \n  err = (((MACHEPF * (n + maxt)) < float(0)) ? -(MACHEPF * (n + maxt)) : (MACHEPF * (n + maxt)));\n  alast = a0;\n  sum += alast;\n  return sum;\n  err = MAXNUMF;\n  mtherr(5);\n  return sum;\n  n -= 1.0;\n  x = (1.0 / x);\n  if ((type == 1)) {\n    alast *= (0.5 + (((((0.125 + (0.25 * b)) - (0.5 * a)) + (0.25 * x)) - (0.25 * n)) / x));\n  } else if ((type == 2)) {\n    alast *= (((((2.0 / 3.0) - b) + (2.0 * a)) + x) - n);\n  } else {\n    ;\n  }\n  err = ((MACHEPF * (n + maxt)) + ((a0 < float(0)) ? -a0 : a0));\n  sum += alast;\n  return sum;\n  err = MAXNUMF;\n  mtherr(5);\n  return sum;\n}",codeJS:"function hyp2f0f(aa, bb, xx, type, err) {\n  let a;\n  let b;\n  let x;\n  let a0;\n  let alast;\n  let t;\n  let tlast;\n  let maxt;\n  let n;\n  let an;\n  let bn;\n  let u;\n  let sum;\n  let temp;\n  a = aa;\n  b = bb;\n  x = xx;\n  an = a;\n  bn = b;\n  a0 = 1.0;\n  alast = 1.0;\n  sum = 0.0;\n  n = 1.0;\n  t = 1.0;\n  tlast = 1.0e9;\n  maxt = 0.0;\n  for (let dowhile_j = 0; (dowhile_j < 1000); dowhile_j++) {\n    if ((an === float(0))) {\n      err = (((MACHEPF * (n + maxt)) < float(0)) ? -(MACHEPF * (n + maxt)) : (MACHEPF * (n + maxt)));\n      alast = a0;\n      sum += alast;\n      return [sum, err];\n      err = MAXNUMF;\n      mtherr(5);\n      return [sum, err];\n      n -= 1.0;\n      x = (1.0 / x);\n      if ((type === 1)) {\n        alast *= (0.5 + (((((0.125 + (0.25 * b)) - (0.5 * a)) + (0.25 * x)) - (0.25 * n)) / x));\n      } else if ((type === 2)) {\n        alast *= (((((2.0 / 3.0) - b) + (2.0 * a)) + x) - n);\n      } else {\n        ;\n      }\n      err = ((MACHEPF * (n + maxt)) + ((a0 < float(0)) ? -a0 : a0));\n      sum += alast;\n      return [sum, err];\n      err = MAXNUMF;\n      mtherr(5);\n      return [sum, err];\n    }\n    if ((bn === float(0))) {\n      err = (((MACHEPF * (n + maxt)) < float(0)) ? -(MACHEPF * (n + maxt)) : (MACHEPF * (n + maxt)));\n      alast = a0;\n      sum += alast;\n      return [sum, err];\n      err = MAXNUMF;\n      mtherr(5);\n      return [sum, err];\n      n -= 1.0;\n      x = (1.0 / x);\n      if ((type === 1)) {\n        alast *= (0.5 + (((((0.125 + (0.25 * b)) - (0.5 * a)) + (0.25 * x)) - (0.25 * n)) / x));\n      } else if ((type === 2)) {\n        alast *= (((((2.0 / 3.0) - b) + (2.0 * a)) + x) - n);\n      } else {\n        ;\n      }\n      err = ((MACHEPF * (n + maxt)) + ((a0 < float(0)) ? -a0 : a0));\n      sum += alast;\n      return [sum, err];\n      err = MAXNUMF;\n      mtherr(5);\n      return [sum, err];\n    }\n    u = (an * ((bn * x) / n));\n    temp = ((u < float(0)) ? -u : u);\n    if (((temp > 1.0) && (maxt > (MAXNUMF / temp)))) {\n      err = MAXNUMF;\n      mtherr(5);\n      return [sum, err];\n    }\n    a0 *= u;\n    t = ((a0 < float(0)) ? -a0 : a0);\n    if ((t > tlast)) {\n      n -= 1.0;\n      x = (1.0 / x);\n      if ((type === 1)) {\n        alast *= (0.5 + (((((0.125 + (0.25 * b)) - (0.5 * a)) + (0.25 * x)) - (0.25 * n)) / x));\n      } else if ((type === 2)) {\n        alast *= (((((2.0 / 3.0) - b) + (2.0 * a)) + x) - n);\n      } else {\n        ;\n      }\n      err = ((MACHEPF * (n + maxt)) + ((a0 < float(0)) ? -a0 : a0));\n      sum += alast;\n      return [sum, err];\n      err = MAXNUMF;\n      mtherr(5);\n      return [sum, err];\n    }\n    tlast = t;\n    sum += alast;\n    alast = a0;\n    if ((n > float(200))) {\n      n -= 1.0;\n      x = (1.0 / x);\n      if ((type === 1)) {\n        alast *= (0.5 + (((((0.125 + (0.25 * b)) - (0.5 * a)) + (0.25 * x)) - (0.25 * n)) / x));\n      } else if ((type === 2)) {\n        alast *= (((((2.0 / 3.0) - b) + (2.0 * a)) + x) - n);\n      } else {\n        ;\n      }\n      err = ((MACHEPF * (n + maxt)) + ((a0 < float(0)) ? -a0 : a0));\n      sum += alast;\n      return [sum, err];\n      err = MAXNUMF;\n      mtherr(5);\n      return [sum, err];\n    }\n    an += 1.0;\n    bn += 1.0;\n    n += 1.0;\n    if ((t > maxt)) maxt = t;\n    if (!(t > MACHEPF)) break;\n  }\n  \n  err = (((MACHEPF * (n + maxt)) < float(0)) ? -(MACHEPF * (n + maxt)) : (MACHEPF * (n + maxt)));\n  alast = a0;\n  sum += alast;\n  return [sum, err];\n  err = MAXNUMF;\n  mtherr(5);\n  return [sum, err];\n  n -= 1.0;\n  x = (1.0 / x);\n  if ((type === 1)) {\n    alast *= (0.5 + (((((0.125 + (0.25 * b)) - (0.5 * a)) + (0.25 * x)) - (0.25 * n)) / x));\n  } else if ((type === 2)) {\n    alast *= (((((2.0 / 3.0) - b) + (2.0 * a)) + x) - n);\n  } else {\n    ;\n  }\n  err = ((MACHEPF * (n + maxt)) + ((a0 < float(0)) ? -a0 : a0));\n  sum += alast;\n  return [sum, err];\n  err = MAXNUMF;\n  mtherr(5);\n  return [sum, err];\n}"})),o.add(new z({dependencies:["float","exp","hypergf_hy1f1pf","mtherr","hypergf_hy1f1af"],constants:[],variables:[],signature:{name:"hypergf_recusive_hypergf",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"bb",type:"float",index:1},{name:"xx",type:"float",index:2}]},codeWebGL:"float hypergf_recusive_hypergf(float aa, float bb, float xx) {\n  // func call multiple return is not used in WebGL;\n  float a;\n  float b;\n  float x;\n  float asum;\n  float psum;\n  float acanc;\n  float pcanc;\n  float temp;\n  a = aa;\n  b = bb;\n  x = xx;\n  temp = (b - a);\n  if ((((temp < float(0)) ? -temp : temp) < (0.001 * ((a < float(0)) ? -a : a)))) return (exp(x) * NAN);\n  psum = hypergf_hy1f1pf(a, b, x, pcanc);\n  if ((pcanc < 1.0e-6)) {\n    if ((pcanc > 1.0e-3)) mtherr(6);\n    return psum;\n  }\n  asum = hypergf_hy1f1af(a, b, x, acanc);\n  if ((acanc < pcanc)) {\n    pcanc = acanc;\n    psum = asum;\n  }\n  if ((pcanc > 1.0e-3)) mtherr(6);\n  return psum;\n}",codeJS:"function hypergf_recusive_hypergf(aa, bb, xx) {\n  let _mainReturn = NaN;\n  let a;\n  let b;\n  let x;\n  let asum;\n  let psum;\n  let acanc;\n  let pcanc;\n  let temp;\n  a = aa;\n  b = bb;\n  x = xx;\n  temp = (b - a);\n  if ((((temp < float(0)) ? -temp : temp) < (0.001 * ((a < float(0)) ? -a : a)))) return (exp(x) * NAN);\n  psum = ([_mainReturn, pcanc] = hypergf_hy1f1pf(a, b, x, pcanc), _mainReturn);\n  if ((pcanc < 1.0e-6)) {\n    if ((pcanc > 1.0e-3)) mtherr(6);\n    return psum;\n  }\n  asum = ([_mainReturn, acanc] = hypergf_hy1f1af(a, b, x, acanc), _mainReturn);\n  if ((acanc < pcanc)) {\n    pcanc = acanc;\n    psum = asum;\n  }\n  if ((pcanc > 1.0e-3)) mtherr(6);\n  return psum;\n}"})),o.add(new v({name:"i0f_A",type:"float",value:new Float32Array([-1.300025009986248e-8,6.046995022541919e-8,-2.670793853940612e-7,11173875391201037e-22,-44167383584587505e-22,16448448070728896e-21,-5754195010082104e-20,.00018850288509584165,-.0005763755745385824,.0016394756169413357,-.004324309995050576,.010546460394594998,-.02373741480589947,.04930528423967071,-.09490109704804764,.17162090152220877,-.3046826723431984,.6767952744094761]),valueString:"-1.30002500998624804212E-8, 6.04699502254191894932E-8, -2.67079385394061173391E-7, 1.11738753912010371815E-6, -4.41673835845875056359E-6, 1.64484480707288970893E-5, -5.75419501008210370398E-5, 1.88502885095841655729E-4, -5.76375574538582365885E-4, 1.63947561694133579842E-3, -4.32430999505057594430E-3, 1.05464603945949983183E-2, -2.37374148058994688156E-2, 4.93052842396707084878E-2, -9.49010970480476444210E-2, 1.71620901522208775349E-1, -3.04682672343198398683E-1, 6.76795274409476084995E-1"})),o.add(new v({name:"i0f_B",type:"float",value:new Float32Array([3.3962320257083865e-9,2.266668990498178e-8,2.0489185894690638e-7,28913705208347567e-22,6889758346916825e-20,.0033691164782556943,.8044904110141088]),valueString:"3.39623202570838634515E-9, 2.26666899049817806459E-8, 2.04891858946906374183E-7, 2.89137052083475648297E-6, 6.88975834691682398426E-5, 3.36911647825569408990E-3, 8.04490411014108831608E-1"})),o.add(new z({dependencies:["float","exp","chbevlf_18","chbevlf_7","sqrt"],constants:["i0f_A","i0f_B"],variables:[],signature:{name:"i0f",type:"float",arguments:[{name:"x",type:"float",index:0}]},codeWebGL:"float i0f(float x) {\n  float y;\n  if ((x < float(0))) x = -x;\n  if ((x <= 8.0)) {\n    y = ((0.5 * x) - 2.0);\n    return (exp(x) * chbevlf_18(y, i0f_A, 18));\n  }\n  return ((exp(x) * chbevlf_7(((32.0 / x) - 2.0), i0f_B, 7)) / sqrt(x));\n}",codeJS:"function i0f(x) {\n  let y;\n  if ((x < float(0))) x = -x;\n  if ((x <= 8.0)) {\n    y = ((0.5 * x) - 2.0);\n    return (exp(x) * chbevlf_18(y, i0f_A, 18));\n  }\n  return ((exp(x) * chbevlf_7(((32.0 / x) - 2.0), i0f_B, 7)) / sqrt(x));\n}"})),o.add(new z({dependencies:["float","chbevlf_18","chbevlf_7","sqrt"],constants:["i0f_A","i0f_B"],variables:[],signature:{name:"i0ef",type:"float",arguments:[{name:"x",type:"float",index:0}]},codeWebGL:"float i0ef(float x) {\n  float y;\n  if ((x < float(0))) x = -x;\n  if ((x <= 8.0)) {\n    y = ((0.5 * x) - 2.0);\n    return chbevlf_18(y, i0f_A, 18);\n  }\n  return (chbevlf_7(((32.0 / x) - 2.0), i0f_B, 7) / sqrt(x));\n}",codeJS:"function i0ef(x) {\n  let y;\n  if ((x < float(0))) x = -x;\n  if ((x <= 8.0)) {\n    y = ((0.5 * x) - 2.0);\n    return chbevlf_18(y, i0f_A, 18);\n  }\n  return (chbevlf_7(((32.0 / x) - 2.0), i0f_B, 7) / sqrt(x));\n}"})),o.add(new v({name:"i1f_A",type:"float",value:new Float32Array([9.381537386495773e-9,-4.445059128796328e-8,2.0032947535521353e-7,-8.568720264695455e-7,34702513081376785e-22,-13273163656039436e-21,4781565107550054e-20,-.00016176081582589674,.0005122859561685758,-.0015135724506312532,.004156422944312888,-.010564084894626197,.024726449030626516,-.05294598120809499,.1026436586898471,-.17641651835783406,.25258718644363365]),valueString:"9.38153738649577178388E-9, -4.44505912879632808065E-8, 2.00329475355213526229E-7, -8.56872026469545474066E-7, 3.47025130813767847674E-6, -1.32731636560394358279E-5, 4.78156510755005422638E-5, -1.61760815825896745588E-4, 5.12285956168575772895E-4, -1.51357245063125314899E-3, 4.15642294431288815669E-3, -1.05640848946261981558E-2, 2.47264490306265168283E-2, -5.29459812080949914269E-2, 1.02643658689847095384E-1, -1.76416518357834055153E-1, 2.52587186443633654823E-1"})),o.add(new v({name:"i1f_B",type:"float",value:new Float32Array([-3.835380385964237e-9,-2.6314688468895196e-8,-2.512236237870209e-7,-3882564808877691e-21,-.00011058893876262371,-.009761097491361469,.7785762350182801]),valueString:"-3.83538038596423702205E-9, -2.63146884688951950684E-8, -2.51223623787020892529E-7, -3.88256480887769039346E-6, -1.10588938762623716291E-4, -9.76109749136146840777E-3, 7.78576235018280120474E-1"})),o.add(new z({dependencies:["float","exp","chbevlf_7","sqrt","chbevlf_17"],constants:["i1f_B","i1f_A"],variables:[],signature:{name:"i1f",type:"float",arguments:[{name:"xx",type:"float",index:0}]},codeWebGL:"float i1f(float xx) {\n  float x;\n  float y;\n  float z;\n  x = xx;\n  z = ((x < float(0)) ? -x : x);\n  if ((z <= 8.0)) {\n    y = ((0.5 * z) - 2.0);\n    z = ((chbevlf_17(y, i1f_A, 17) * z) * exp(z));\n  } else {\n    z = ((exp(z) * chbevlf_7(((32.0 / z) - 2.0), i1f_B, 7)) / sqrt(z));\n  }\n  if ((x < 0.0)) z = -z;\n  return z;\n}",codeJS:"function i1f(xx) {\n  let x;\n  let y;\n  let z;\n  x = xx;\n  z = ((x < float(0)) ? -x : x);\n  if ((z <= 8.0)) {\n    y = ((0.5 * z) - 2.0);\n    z = ((chbevlf_17(y, i1f_A, 17) * z) * exp(z));\n  } else {\n    z = ((exp(z) * chbevlf_7(((32.0 / z) - 2.0), i1f_B, 7)) / sqrt(z));\n  }\n  if ((x < 0.0)) z = -z;\n  return z;\n}"})),o.add(new z({dependencies:["float","chbevlf_7","sqrt","chbevlf_17"],constants:["i1f_B","i1f_A"],variables:[],signature:{name:"i1ef",type:"float",arguments:[{name:"xx",type:"float",index:0}]},codeWebGL:"float i1ef(float xx) {\n  float x;\n  float y;\n  float z;\n  x = xx;\n  z = ((x < float(0)) ? -x : x);\n  if ((z <= 8.0)) {\n    y = ((0.5 * z) - 2.0);\n    z = (chbevlf_17(y, i1f_A, 17) * z);\n  } else {\n    z = (chbevlf_7(((32.0 / z) - 2.0), i1f_B, 7) / sqrt(z));\n  }\n  if ((x < 0.0)) z = -z;\n  return z;\n}",codeJS:"function i1ef(xx) {\n  let x;\n  let y;\n  let z;\n  x = xx;\n  z = ((x < float(0)) ? -x : x);\n  if ((z <= 8.0)) {\n    y = ((0.5 * z) - 2.0);\n    z = (chbevlf_17(y, i1f_A, 17) * z);\n  } else {\n    z = (chbevlf_7(((32.0 / z) - 2.0), i1f_B, 7) / sqrt(z));\n  }\n  if ((x < 0.0)) z = -z;\n  return z;\n}"})),o.add(new z({dependencies:["float","igamcf_recusive_igamf","log","lgamf","mtherr","exp"],constants:["MAXLOGF","MACHEPF"],variables:[],signature:{name:"igamcf",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"xx",type:"float",index:1}]},codeWebGL:"float igamcf(float aa, float xx) {\n  float a;\n  float x;\n  float ans;\n  float c;\n  float yc;\n  float ax;\n  float y;\n  float z;\n  float pk;\n  float pkm1;\n  float pkm2;\n  float qk;\n  float qkm1;\n  float qkm2;\n  float r;\n  float t;\n  float big = 16777216.;\n  a = aa;\n  x = xx;\n  if (((x <= float(0)) || (a <= float(0)))) return 1.0;\n  if (((x < 1.0) || (x < a))) return (1.0 - igamcf_recusive_igamf(a, x));\n  ax = (((a * log(x)) - x) - lgamf(a));\n  if ((ax < -MAXLOGF)) {\n    mtherr(4);\n    return 0.0;\n  }\n  ax = exp(ax);\n  y = (1.0 - a);\n  z = ((x + y) + 1.0);\n  c = 0.0;\n  pkm2 = 1.0;\n  qkm2 = x;\n  pkm1 = (x + 1.0);\n  qkm1 = (z * x);\n  ans = (pkm1 / qkm1);\n  for (int dowhile_i = 0; (dowhile_i < 1000); dowhile_i++) {\n    c += 1.0;\n    y += 1.0;\n    z += 2.0;\n    yc = (y * c);\n    pk = ((pkm1 * z) - (pkm2 * yc));\n    qk = ((qkm1 * z) - (qkm2 * yc));\n    if ((qk != float(0))) {\n      r = (pk / qk);\n      t = ((((ans - r) / r) < float(0)) ? -((ans - r) / r) : ((ans - r) / r));\n      ans = r;\n    } else t = 1.0;\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    if ((((pk < float(0)) ? -pk : pk) > big)) {\n      pkm2 *= MACHEPF;\n      pkm1 *= MACHEPF;\n      qkm2 *= MACHEPF;\n      qkm1 *= MACHEPF;\n    }\n    if (!(t > MACHEPF)) break;\n  }\n  \n  return (ans * ax);\n}",codeJS:"function igamcf(aa, xx) {\n  let a;\n  let x;\n  let ans;\n  let c;\n  let yc;\n  let ax;\n  let y;\n  let z;\n  let pk;\n  let pkm1;\n  let pkm2;\n  let qk;\n  let qkm1;\n  let qkm2;\n  let r;\n  let t;\n  let big = 16777216.;\n  a = aa;\n  x = xx;\n  if (((x <= float(0)) || (a <= float(0)))) return 1.0;\n  if (((x < 1.0) || (x < a))) return (1.0 - igamcf_recusive_igamf(a, x));\n  ax = (((a * log(x)) - x) - lgamf(a));\n  if ((ax < -MAXLOGF)) {\n    mtherr(4);\n    return 0.0;\n  }\n  ax = exp(ax);\n  y = (1.0 - a);\n  z = ((x + y) + 1.0);\n  c = 0.0;\n  pkm2 = 1.0;\n  qkm2 = x;\n  pkm1 = (x + 1.0);\n  qkm1 = (z * x);\n  ans = (pkm1 / qkm1);\n  for (let dowhile_i = 0; (dowhile_i < 1000); dowhile_i++) {\n    c += 1.0;\n    y += 1.0;\n    z += 2.0;\n    yc = (y * c);\n    pk = ((pkm1 * z) - (pkm2 * yc));\n    qk = ((qkm1 * z) - (qkm2 * yc));\n    if ((qk !== float(0))) {\n      r = (pk / qk);\n      t = ((((ans - r) / r) < float(0)) ? -((ans - r) / r) : ((ans - r) / r));\n      ans = r;\n    } else t = 1.0;\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    if ((((pk < float(0)) ? -pk : pk) > big)) {\n      pkm2 *= MACHEPF;\n      pkm1 *= MACHEPF;\n      qkm2 *= MACHEPF;\n      qkm1 *= MACHEPF;\n    }\n    if (!(t > MACHEPF)) break;\n  }\n  \n  return (ans * ax);\n}"})),o.add(new z({dependencies:["float","igamf_recusive_igamcf","log","lgamf","mtherr","exp"],constants:["MAXLOGF","MACHEPF"],variables:[],signature:{name:"igamf",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"xx",type:"float",index:1}]},codeWebGL:"float igamf(float aa, float xx) {\n  float a;\n  float x;\n  float ans;\n  float ax;\n  float c;\n  float r;\n  a = aa;\n  x = xx;\n  if (((x <= float(0)) || (a <= float(0)))) return 0.0;\n  if (((x > 1.0) && (x > a))) return (1.0 - igamf_recusive_igamcf(a, x));\n  ax = (((a * log(x)) - x) - lgamf(a));\n  if ((ax < -MAXLOGF)) {\n    mtherr(4);\n    return 0.0;\n  }\n  ax = exp(ax);\n  r = a;\n  c = 1.0;\n  ans = 1.0;\n  for (int dowhile_j = 0; (dowhile_j < 1000); dowhile_j++) {\n    r += 1.0;\n    c *= (x / r);\n    ans += c;\n    if (!((c / ans) > MACHEPF)) break;\n  }\n  \n  return ((ans * ax) / a);\n}",codeJS:"function igamf(aa, xx) {\n  let a;\n  let x;\n  let ans;\n  let ax;\n  let c;\n  let r;\n  a = aa;\n  x = xx;\n  if (((x <= float(0)) || (a <= float(0)))) return 0.0;\n  if (((x > 1.0) && (x > a))) return (1.0 - igamf_recusive_igamcf(a, x));\n  ax = (((a * log(x)) - x) - lgamf(a));\n  if ((ax < -MAXLOGF)) {\n    mtherr(4);\n    return 0.0;\n  }\n  ax = exp(ax);\n  r = a;\n  c = 1.0;\n  ans = 1.0;\n  for (let dowhile_j = 0; (dowhile_j < 1000); dowhile_j++) {\n    r += 1.0;\n    c *= (x / r);\n    ans += c;\n    if (!((c / ans) > MACHEPF)) break;\n  }\n  \n  return ((ans * ax) / a);\n}"})),o.add(new z({dependencies:["float","log","lgamf","mtherr","exp"],constants:["MAXLOGF","MACHEPF"],variables:[],signature:{name:"igamcf_recusive_igamf",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"xx",type:"float",index:1}]},codeWebGL:"float igamcf_recusive_igamf(float aa, float xx) {\n  float a;\n  float x;\n  float ans;\n  float ax;\n  float c;\n  float r;\n  a = aa;\n  x = xx;\n  if (((x <= float(0)) || (a <= float(0)))) return 0.0;\n  if (((x > 1.0) && (x > a))) return (1.0 - NAN);\n  ax = (((a * log(x)) - x) - lgamf(a));\n  if ((ax < -MAXLOGF)) {\n    mtherr(4);\n    return 0.0;\n  }\n  ax = exp(ax);\n  r = a;\n  c = 1.0;\n  ans = 1.0;\n  for (int dowhile_k = 0; (dowhile_k < 1000); dowhile_k++) {\n    r += 1.0;\n    c *= (x / r);\n    ans += c;\n    if (!((c / ans) > MACHEPF)) break;\n  }\n  \n  return ((ans * ax) / a);\n}",codeJS:"function igamcf_recusive_igamf(aa, xx) {\n  let a;\n  let x;\n  let ans;\n  let ax;\n  let c;\n  let r;\n  a = aa;\n  x = xx;\n  if (((x <= float(0)) || (a <= float(0)))) return 0.0;\n  if (((x > 1.0) && (x > a))) return (1.0 - NAN);\n  ax = (((a * log(x)) - x) - lgamf(a));\n  if ((ax < -MAXLOGF)) {\n    mtherr(4);\n    return 0.0;\n  }\n  ax = exp(ax);\n  r = a;\n  c = 1.0;\n  ans = 1.0;\n  for (let dowhile_k = 0; (dowhile_k < 1000); dowhile_k++) {\n    r += 1.0;\n    c *= (x / r);\n    ans += c;\n    if (!((c / ans) > MACHEPF)) break;\n  }\n  \n  return ((ans * ax) / a);\n}"})),o.add(new z({dependencies:["float","igamcf_recusive_igamf","log","lgamf","mtherr","exp"],constants:["MAXLOGF","MACHEPF"],variables:[],signature:{name:"igamf_recusive_igamcf",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"xx",type:"float",index:1}]},codeWebGL:"float igamf_recusive_igamcf(float aa, float xx) {\n  float a;\n  float x;\n  float ans;\n  float c;\n  float yc;\n  float ax;\n  float y;\n  float z;\n  float pk;\n  float pkm1;\n  float pkm2;\n  float qk;\n  float qkm1;\n  float qkm2;\n  float r;\n  float t;\n  float big = 16777216.;\n  a = aa;\n  x = xx;\n  if (((x <= float(0)) || (a <= float(0)))) return 1.0;\n  if (((x < 1.0) || (x < a))) return (1.0 - igamcf_recusive_igamf(a, x));\n  ax = (((a * log(x)) - x) - lgamf(a));\n  if ((ax < -MAXLOGF)) {\n    mtherr(4);\n    return 0.0;\n  }\n  ax = exp(ax);\n  y = (1.0 - a);\n  z = ((x + y) + 1.0);\n  c = 0.0;\n  pkm2 = 1.0;\n  qkm2 = x;\n  pkm1 = (x + 1.0);\n  qkm1 = (z * x);\n  ans = (pkm1 / qkm1);\n  for (int dowhile_a = 0; (dowhile_a < 1000); dowhile_a++) {\n    c += 1.0;\n    y += 1.0;\n    z += 2.0;\n    yc = (y * c);\n    pk = ((pkm1 * z) - (pkm2 * yc));\n    qk = ((qkm1 * z) - (qkm2 * yc));\n    if ((qk != float(0))) {\n      r = (pk / qk);\n      t = ((((ans - r) / r) < float(0)) ? -((ans - r) / r) : ((ans - r) / r));\n      ans = r;\n    } else t = 1.0;\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    if ((((pk < float(0)) ? -pk : pk) > big)) {\n      pkm2 *= MACHEPF;\n      pkm1 *= MACHEPF;\n      qkm2 *= MACHEPF;\n      qkm1 *= MACHEPF;\n    }\n    if (!(t > MACHEPF)) break;\n  }\n  \n  return (ans * ax);\n}",codeJS:"function igamf_recusive_igamcf(aa, xx) {\n  let a;\n  let x;\n  let ans;\n  let c;\n  let yc;\n  let ax;\n  let y;\n  let z;\n  let pk;\n  let pkm1;\n  let pkm2;\n  let qk;\n  let qkm1;\n  let qkm2;\n  let r;\n  let t;\n  let big = 16777216.;\n  a = aa;\n  x = xx;\n  if (((x <= float(0)) || (a <= float(0)))) return 1.0;\n  if (((x < 1.0) || (x < a))) return (1.0 - igamcf_recusive_igamf(a, x));\n  ax = (((a * log(x)) - x) - lgamf(a));\n  if ((ax < -MAXLOGF)) {\n    mtherr(4);\n    return 0.0;\n  }\n  ax = exp(ax);\n  y = (1.0 - a);\n  z = ((x + y) + 1.0);\n  c = 0.0;\n  pkm2 = 1.0;\n  qkm2 = x;\n  pkm1 = (x + 1.0);\n  qkm1 = (z * x);\n  ans = (pkm1 / qkm1);\n  for (let dowhile_a = 0; (dowhile_a < 1000); dowhile_a++) {\n    c += 1.0;\n    y += 1.0;\n    z += 2.0;\n    yc = (y * c);\n    pk = ((pkm1 * z) - (pkm2 * yc));\n    qk = ((qkm1 * z) - (qkm2 * yc));\n    if ((qk !== float(0))) {\n      r = (pk / qk);\n      t = ((((ans - r) / r) < float(0)) ? -((ans - r) / r) : ((ans - r) / r));\n      ans = r;\n    } else t = 1.0;\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    if ((((pk < float(0)) ? -pk : pk) > big)) {\n      pkm2 *= MACHEPF;\n      pkm1 *= MACHEPF;\n      qkm2 *= MACHEPF;\n      qkm1 *= MACHEPF;\n    }\n    if (!(t > MACHEPF)) break;\n  }\n  \n  return (ans * ax);\n}"})),o.add(new z({dependencies:["mtherr","incbetf_recusive_incbetf","log","lgamf","exp","float","incbpsf","bool","incbetf_incbdf","incbetf_incbcff"],constants:["MAXLOGF"],variables:[],signature:{name:"incbetf",type:"float",arguments:[{name:"aaa",type:"float",index:0},{name:"bbb",type:"float",index:1},{name:"xxx",type:"float",index:2}]},codeWebGL:"float incbetf(float aaa, float bbb, float xxx) {\n  float aa;\n  float bb;\n  float xx;\n  float ans;\n  float a;\n  float b;\n  float t;\n  float x;\n  float onemx;\n  int flag;\n  aa = aaa;\n  bb = bbb;\n  xx = xxx;\n  if (((xx <= 0.0) || (xx >= 1.0))) {\n    if ((xx == 0.0)) return 0.0;\n    if ((xx == 1.0)) return 1.0;\n    mtherr(1);\n    return 0.0;\n  }\n  onemx = (1.0 - xx);\n  if ((aa <= 1.0)) {\n    ans = incbetf_recusive_incbetf((aa + 1.0), bb, xx);\n    t = (((((aa * log(xx)) + (bb * log((1.0 - xx)))) + lgamf((aa + bb))) - lgamf((aa + 1.0))) - lgamf(bb));\n    if ((t > -MAXLOGF)) ans += exp(t);\n    return ans;\n  }\n  if ((xx > (aa / (aa + bb)))) {\n    flag = 1;\n    a = bb;\n    b = aa;\n    t = xx;\n    x = onemx;\n  } else {\n    flag = 0;\n    a = aa;\n    b = bb;\n    t = onemx;\n    x = xx;\n  }\n  if ((b > 10.0)) {\n    if ((((((b * x) / a) < float(0)) ? -((b * x) / a) : ((b * x) / a)) < 0.3)) {\n      t = incbpsf(a, b, x);\n      if (bool(flag)) t = (1.0 - t);\n      return t;\n    }\n  }\n  ans = ((x * ((a + b) - 2.0)) / (a - 1.0));\n  if ((ans < 1.0)) {\n    ans = incbetf_incbcff(a, b, x);\n    t = (b * log(t));\n  } else {\n    ans = incbetf_incbdf(a, b, x);\n    t = ((b - 1.0) * log(t));\n  }\n  t += ((((a * log(x)) + lgamf((a + b))) - lgamf(a)) - lgamf(b));\n  t += log((ans / a));\n  if ((t < -MAXLOGF)) {\n    t = 0.0;\n    if ((flag == 0)) {\n      mtherr(4);\n    }\n  } else {\n    t = exp(t);\n  }\n  if (bool(flag)) t = (1.0 - t);\n  return t;\n}",codeJS:"function incbetf(aaa, bbb, xxx) {\n  let aa;\n  let bb;\n  let xx;\n  let ans;\n  let a;\n  let b;\n  let t;\n  let x;\n  let onemx;\n  let flag;\n  aa = aaa;\n  bb = bbb;\n  xx = xxx;\n  if (((xx <= 0.0) || (xx >= 1.0))) {\n    if ((xx === 0.0)) return 0.0;\n    if ((xx === 1.0)) return 1.0;\n    mtherr(1);\n    return 0.0;\n  }\n  onemx = (1.0 - xx);\n  if ((aa <= 1.0)) {\n    ans = incbetf_recusive_incbetf((aa + 1.0), bb, xx);\n    t = (((((aa * log(xx)) + (bb * log((1.0 - xx)))) + lgamf((aa + bb))) - lgamf((aa + 1.0))) - lgamf(bb));\n    if ((t > -MAXLOGF)) ans += exp(t);\n    return ans;\n  }\n  if ((xx > (aa / (aa + bb)))) {\n    flag = 1;\n    a = bb;\n    b = aa;\n    t = xx;\n    x = onemx;\n  } else {\n    flag = 0;\n    a = aa;\n    b = bb;\n    t = onemx;\n    x = xx;\n  }\n  if ((b > 10.0)) {\n    if ((((((b * x) / a) < float(0)) ? -((b * x) / a) : ((b * x) / a)) < 0.3)) {\n      t = incbpsf(a, b, x);\n      if (bool(flag)) t = (1.0 - t);\n      return t;\n    }\n  }\n  ans = ((x * ((a + b) - 2.0)) / (a - 1.0));\n  if ((ans < 1.0)) {\n    ans = incbetf_incbcff(a, b, x);\n    t = (b * log(t));\n  } else {\n    ans = incbetf_incbdf(a, b, x);\n    t = ((b - 1.0) * log(t));\n  }\n  t += ((((a * log(x)) + lgamf((a + b))) - lgamf(a)) - lgamf(b));\n  t += log((ans / a));\n  if ((t < -MAXLOGF)) {\n    t = 0.0;\n    if ((flag === 0)) {\n      mtherr(4);\n    }\n  } else {\n    t = exp(t);\n  }\n  if (bool(flag)) t = (1.0 - t);\n  return t;\n}"})),o.add(new z({dependencies:["float"],constants:["MACHEPF"],variables:[],signature:{name:"incbetf_incbcff",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"bb",type:"float",index:1},{name:"xx",type:"float",index:2}]},codeWebGL:"float incbetf_incbcff(float aa, float bb, float xx) {\n  float a;\n  float b;\n  float x;\n  float xk;\n  float pk;\n  float pkm1;\n  float pkm2;\n  float qk;\n  float qkm1;\n  float qkm2;\n  float k1;\n  float k2;\n  float k3;\n  float k4;\n  float k5;\n  float k6;\n  float k7;\n  float k8;\n  float r;\n  float t;\n  float ans;\n  float big = 16777216.;\n  int n;\n  a = aa;\n  b = bb;\n  x = xx;\n  k1 = a;\n  k2 = (a + b);\n  k3 = a;\n  k4 = (a + 1.0);\n  k5 = 1.0;\n  k6 = (b - 1.0);\n  k7 = k4;\n  k8 = (a + 2.0);\n  pkm2 = 0.0;\n  qkm2 = 1.0;\n  pkm1 = 1.0;\n  qkm1 = 1.0;\n  ans = 1.0;\n  r = 0.0;\n  n = 0;\n  for (int dowhile_i = 0; (dowhile_i < 1000); dowhile_i++) {\n    xk = (-((x * k1) * k2) / (k3 * k4));\n    pk = (pkm1 + (pkm2 * xk));\n    qk = (qkm1 + (qkm2 * xk));\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    xk = (((x * k5) * k6) / (k7 * k8));\n    pk = (pkm1 + (pkm2 * xk));\n    qk = (qkm1 + (qkm2 * xk));\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    if ((qk != float(0))) r = (pk / qk);\n    if ((r != float(0))) {\n      t = ((((ans - r) / r) < float(0)) ? -((ans - r) / r) : ((ans - r) / r));\n      ans = r;\n    } else t = 1.0;\n    if ((t < MACHEPF)) {\n      return ans;\n    }\n    k1 += 1.0;\n    k2 += 1.0;\n    k3 += 2.0;\n    k4 += 2.0;\n    k5 += 1.0;\n    k6 -= 1.0;\n    k7 += 2.0;\n    k8 += 2.0;\n    if (((((qk < float(0)) ? -qk : qk) + ((pk < float(0)) ? -pk : pk)) > big)) {\n      pkm2 *= MACHEPF;\n      pkm1 *= MACHEPF;\n      qkm2 *= MACHEPF;\n      qkm1 *= MACHEPF;\n    }\n    if (((((qk < float(0)) ? -qk : qk) < MACHEPF) || (((pk < float(0)) ? -pk : pk) < MACHEPF))) {\n      pkm2 *= big;\n      pkm1 *= big;\n      qkm2 *= big;\n      qkm1 *= big;\n    }\n    if (!(++n < 100)) break;\n  }\n  \n  return ans;\n}",codeJS:"function incbetf_incbcff(aa, bb, xx) {\n  let a;\n  let b;\n  let x;\n  let xk;\n  let pk;\n  let pkm1;\n  let pkm2;\n  let qk;\n  let qkm1;\n  let qkm2;\n  let k1;\n  let k2;\n  let k3;\n  let k4;\n  let k5;\n  let k6;\n  let k7;\n  let k8;\n  let r;\n  let t;\n  let ans;\n  let big = 16777216.;\n  let n;\n  a = aa;\n  b = bb;\n  x = xx;\n  k1 = a;\n  k2 = (a + b);\n  k3 = a;\n  k4 = (a + 1.0);\n  k5 = 1.0;\n  k6 = (b - 1.0);\n  k7 = k4;\n  k8 = (a + 2.0);\n  pkm2 = 0.0;\n  qkm2 = 1.0;\n  pkm1 = 1.0;\n  qkm1 = 1.0;\n  ans = 1.0;\n  r = 0.0;\n  n = 0;\n  for (let dowhile_i = 0; (dowhile_i < 1000); dowhile_i++) {\n    xk = (-((x * k1) * k2) / (k3 * k4));\n    pk = (pkm1 + (pkm2 * xk));\n    qk = (qkm1 + (qkm2 * xk));\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    xk = (((x * k5) * k6) / (k7 * k8));\n    pk = (pkm1 + (pkm2 * xk));\n    qk = (qkm1 + (qkm2 * xk));\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    if ((qk !== float(0))) r = (pk / qk);\n    if ((r !== float(0))) {\n      t = ((((ans - r) / r) < float(0)) ? -((ans - r) / r) : ((ans - r) / r));\n      ans = r;\n    } else t = 1.0;\n    if ((t < MACHEPF)) {\n      return ans;\n    }\n    k1 += 1.0;\n    k2 += 1.0;\n    k3 += 2.0;\n    k4 += 2.0;\n    k5 += 1.0;\n    k6 -= 1.0;\n    k7 += 2.0;\n    k8 += 2.0;\n    if (((((qk < float(0)) ? -qk : qk) + ((pk < float(0)) ? -pk : pk)) > big)) {\n      pkm2 *= MACHEPF;\n      pkm1 *= MACHEPF;\n      qkm2 *= MACHEPF;\n      qkm1 *= MACHEPF;\n    }\n    if (((((qk < float(0)) ? -qk : qk) < MACHEPF) || (((pk < float(0)) ? -pk : pk) < MACHEPF))) {\n      pkm2 *= big;\n      pkm1 *= big;\n      qkm2 *= big;\n      qkm1 *= big;\n    }\n    if (!(++n < 100)) break;\n  }\n  \n  return ans;\n}"})),o.add(new z({dependencies:["float"],constants:["MACHEPF"],variables:[],signature:{name:"incbetf_incbdf",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"bb",type:"float",index:1},{name:"xx",type:"float",index:2}]},codeWebGL:"float incbetf_incbdf(float aa, float bb, float xx) {\n  float a;\n  float b;\n  float x;\n  float xk;\n  float pk;\n  float pkm1;\n  float pkm2;\n  float qk;\n  float qkm1;\n  float qkm2;\n  float k1;\n  float k2;\n  float k3;\n  float k4;\n  float k5;\n  float k6;\n  float k7;\n  float k8;\n  float r;\n  float t;\n  float ans;\n  float z;\n  float big = 16777216.;\n  int n;\n  a = aa;\n  b = bb;\n  x = xx;\n  k1 = a;\n  k2 = (b - 1.0);\n  k3 = a;\n  k4 = (a + 1.0);\n  k5 = 1.0;\n  k6 = (a + b);\n  k7 = (a + 1.0);\n  ;\n  k8 = (a + 2.0);\n  pkm2 = 0.0;\n  qkm2 = 1.0;\n  pkm1 = 1.0;\n  qkm1 = 1.0;\n  z = (x / (1.0 - x));\n  ans = 1.0;\n  r = 0.0;\n  n = 0;\n  for (int dowhile_j = 0; (dowhile_j < 1000); dowhile_j++) {\n    xk = (-((z * k1) * k2) / (k3 * k4));\n    pk = (pkm1 + (pkm2 * xk));\n    qk = (qkm1 + (qkm2 * xk));\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    xk = (((z * k5) * k6) / (k7 * k8));\n    pk = (pkm1 + (pkm2 * xk));\n    qk = (qkm1 + (qkm2 * xk));\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    if ((qk != float(0))) r = (pk / qk);\n    if ((r != float(0))) {\n      t = ((((ans - r) / r) < float(0)) ? -((ans - r) / r) : ((ans - r) / r));\n      ans = r;\n    } else t = 1.0;\n    if ((t < MACHEPF)) {\n      return ans;\n    }\n    k1 += 1.0;\n    k2 -= 1.0;\n    k3 += 2.0;\n    k4 += 2.0;\n    k5 += 1.0;\n    k6 += 1.0;\n    k7 += 2.0;\n    k8 += 2.0;\n    if (((((qk < float(0)) ? -qk : qk) + ((pk < float(0)) ? -pk : pk)) > big)) {\n      pkm2 *= MACHEPF;\n      pkm1 *= MACHEPF;\n      qkm2 *= MACHEPF;\n      qkm1 *= MACHEPF;\n    }\n    if (((((qk < float(0)) ? -qk : qk) < MACHEPF) || (((pk < float(0)) ? -pk : pk) < MACHEPF))) {\n      pkm2 *= big;\n      pkm1 *= big;\n      qkm2 *= big;\n      qkm1 *= big;\n    }\n    if (!(++n < 100)) break;\n  }\n  \n  return ans;\n}",codeJS:"function incbetf_incbdf(aa, bb, xx) {\n  let a;\n  let b;\n  let x;\n  let xk;\n  let pk;\n  let pkm1;\n  let pkm2;\n  let qk;\n  let qkm1;\n  let qkm2;\n  let k1;\n  let k2;\n  let k3;\n  let k4;\n  let k5;\n  let k6;\n  let k7;\n  let k8;\n  let r;\n  let t;\n  let ans;\n  let z;\n  let big = 16777216.;\n  let n;\n  a = aa;\n  b = bb;\n  x = xx;\n  k1 = a;\n  k2 = (b - 1.0);\n  k3 = a;\n  k4 = (a + 1.0);\n  k5 = 1.0;\n  k6 = (a + b);\n  k7 = (a + 1.0);\n  ;\n  k8 = (a + 2.0);\n  pkm2 = 0.0;\n  qkm2 = 1.0;\n  pkm1 = 1.0;\n  qkm1 = 1.0;\n  z = (x / (1.0 - x));\n  ans = 1.0;\n  r = 0.0;\n  n = 0;\n  for (let dowhile_j = 0; (dowhile_j < 1000); dowhile_j++) {\n    xk = (-((z * k1) * k2) / (k3 * k4));\n    pk = (pkm1 + (pkm2 * xk));\n    qk = (qkm1 + (qkm2 * xk));\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    xk = (((z * k5) * k6) / (k7 * k8));\n    pk = (pkm1 + (pkm2 * xk));\n    qk = (qkm1 + (qkm2 * xk));\n    pkm2 = pkm1;\n    pkm1 = pk;\n    qkm2 = qkm1;\n    qkm1 = qk;\n    if ((qk !== float(0))) r = (pk / qk);\n    if ((r !== float(0))) {\n      t = ((((ans - r) / r) < float(0)) ? -((ans - r) / r) : ((ans - r) / r));\n      ans = r;\n    } else t = 1.0;\n    if ((t < MACHEPF)) {\n      return ans;\n    }\n    k1 += 1.0;\n    k2 -= 1.0;\n    k3 += 2.0;\n    k4 += 2.0;\n    k5 += 1.0;\n    k6 += 1.0;\n    k7 += 2.0;\n    k8 += 2.0;\n    if (((((qk < float(0)) ? -qk : qk) + ((pk < float(0)) ? -pk : pk)) > big)) {\n      pkm2 *= MACHEPF;\n      pkm1 *= MACHEPF;\n      qkm2 *= MACHEPF;\n      qkm1 *= MACHEPF;\n    }\n    if (((((qk < float(0)) ? -qk : qk) < MACHEPF) || (((pk < float(0)) ? -pk : pk) < MACHEPF))) {\n      pkm2 *= big;\n      pkm1 *= big;\n      qkm2 *= big;\n      qkm1 *= big;\n    }\n    if (!(++n < 100)) break;\n  }\n  \n  return ans;\n}"})),o.add(new z({dependencies:["log","lgamf","float","exp","mtherr"],constants:["MACHEPF","MAXLOGF"],variables:[],signature:{name:"incbpsf",type:"float",arguments:[{name:"aa",type:"float",index:0},{name:"bb",type:"float",index:1},{name:"xx",type:"float",index:2}]},codeWebGL:"float incbpsf(float aa, float bb, float xx) {\n  float a;\n  float b;\n  float x;\n  float t;\n  float u;\n  float y;\n  float s;\n  a = aa;\n  b = bb;\n  x = xx;\n  y = (((a * log(x)) + ((b - 1.0) * log((1.0 - x)))) - log(a));\n  y -= (lgamf(a) + lgamf(b));\n  y += lgamf((a + b));\n  t = (x / (1.0 - x));\n  s = 0.0;\n  u = 1.0;\n  for (int dowhile_k = 0; (dowhile_k < 1000); dowhile_k++) {\n    b -= 1.0;\n    if ((b == 0.0)) break;\n    a += 1.0;\n    u *= ((t * b) / a);\n    s += u;\n    if (!(((u < float(0)) ? -u : u) > MACHEPF)) break;\n  }\n  \n  if ((y < -MAXLOGF)) {\n    mtherr(4);\n    s = 0.0;\n  } else s = (exp(y) * (1.0 + s));\n  return s;\n}",codeJS:"function incbpsf(aa, bb, xx) {\n  let a;\n  let b;\n  let x;\n  let t;\n  let u;\n  let y;\n  let s;\n  a = aa;\n  b = bb;\n  x = xx;\n  y = (((a * log(x)) + ((b - 1.0) * log((1.0 - x)))) - log(a));\n  y -= (lgamf(a) + lgamf(b));\n  y += lgamf((a + b));\n  t = (x / (1.0 - x));\n  s = 0.0;\n  u = 1.0;\n  for (let dowhile_k = 0; (dowhile_k < 1000); dowhile_k++) {\n    b -= 1.0;\n    if ((b === 0.0)) break;\n    a += 1.0;\n    u *= ((t * b) / a);\n    s += u;\n    if (!(((u < float(0)) ? -u : u) > MACHEPF)) break;\n  }\n  \n  if ((y < -MAXLOGF)) {\n    mtherr(4);\n    s = 0.0;\n  } else s = (exp(y) * (1.0 + s));\n  return s;\n}"})),o.add(new z({dependencies:["mtherr","log","lgamf","exp","float","incbpsf","bool","incbetf_incbdf","incbetf_incbcff"],constants:["MAXLOGF"],variables:[],signature:{name:"incbetf_recusive_incbetf",type:"float",arguments:[{name:"aaa",type:"float",index:0},{name:"bbb",type:"float",index:1},{name:"xxx",type:"float",index:2}]},codeWebGL:"float incbetf_recusive_incbetf(float aaa, float bbb, float xxx) {\n  float aa;\n  float bb;\n  float xx;\n  float ans;\n  float a;\n  float b;\n  float t;\n  float x;\n  float onemx;\n  int flag;\n  aa = aaa;\n  bb = bbb;\n  xx = xxx;\n  if (((xx <= 0.0) || (xx >= 1.0))) {\n    if ((xx == 0.0)) return 0.0;\n    if ((xx == 1.0)) return 1.0;\n    mtherr(1);\n    return 0.0;\n  }\n  onemx = (1.0 - xx);\n  if ((aa <= 1.0)) {\n    ans = NAN;\n    t = (((((aa * log(xx)) + (bb * log((1.0 - xx)))) + lgamf((aa + bb))) - lgamf((aa + 1.0))) - lgamf(bb));\n    if ((t > -MAXLOGF)) ans += exp(t);\n    return ans;\n  }\n  if ((xx > (aa / (aa + bb)))) {\n    flag = 1;\n    a = bb;\n    b = aa;\n    t = xx;\n    x = onemx;\n  } else {\n    flag = 0;\n    a = aa;\n    b = bb;\n    t = onemx;\n    x = xx;\n  }\n  if ((b > 10.0)) {\n    if ((((((b * x) / a) < float(0)) ? -((b * x) / a) : ((b * x) / a)) < 0.3)) {\n      t = incbpsf(a, b, x);\n      if (bool(flag)) t = (1.0 - t);\n      return t;\n    }\n  }\n  ans = ((x * ((a + b) - 2.0)) / (a - 1.0));\n  if ((ans < 1.0)) {\n    ans = incbetf_incbcff(a, b, x);\n    t = (b * log(t));\n  } else {\n    ans = incbetf_incbdf(a, b, x);\n    t = ((b - 1.0) * log(t));\n  }\n  t += ((((a * log(x)) + lgamf((a + b))) - lgamf(a)) - lgamf(b));\n  t += log((ans / a));\n  if ((t < -MAXLOGF)) {\n    t = 0.0;\n    if ((flag == 0)) {\n      mtherr(4);\n    }\n  } else {\n    t = exp(t);\n  }\n  if (bool(flag)) t = (1.0 - t);\n  return t;\n}",codeJS:"function incbetf_recusive_incbetf(aaa, bbb, xxx) {\n  let aa;\n  let bb;\n  let xx;\n  let ans;\n  let a;\n  let b;\n  let t;\n  let x;\n  let onemx;\n  let flag;\n  aa = aaa;\n  bb = bbb;\n  xx = xxx;\n  if (((xx <= 0.0) || (xx >= 1.0))) {\n    if ((xx === 0.0)) return 0.0;\n    if ((xx === 1.0)) return 1.0;\n    mtherr(1);\n    return 0.0;\n  }\n  onemx = (1.0 - xx);\n  if ((aa <= 1.0)) {\n    ans = NAN;\n    t = (((((aa * log(xx)) + (bb * log((1.0 - xx)))) + lgamf((aa + bb))) - lgamf((aa + 1.0))) - lgamf(bb));\n    if ((t > -MAXLOGF)) ans += exp(t);\n    return ans;\n  }\n  if ((xx > (aa / (aa + bb)))) {\n    flag = 1;\n    a = bb;\n    b = aa;\n    t = xx;\n    x = onemx;\n  } else {\n    flag = 0;\n    a = aa;\n    b = bb;\n    t = onemx;\n    x = xx;\n  }\n  if ((b > 10.0)) {\n    if ((((((b * x) / a) < float(0)) ? -((b * x) / a) : ((b * x) / a)) < 0.3)) {\n      t = incbpsf(a, b, x);\n      if (bool(flag)) t = (1.0 - t);\n      return t;\n    }\n  }\n  ans = ((x * ((a + b) - 2.0)) / (a - 1.0));\n  if ((ans < 1.0)) {\n    ans = incbetf_incbcff(a, b, x);\n    t = (b * log(t));\n  } else {\n    ans = incbetf_incbdf(a, b, x);\n    t = ((b - 1.0) * log(t));\n  }\n  t += ((((a * log(x)) + lgamf((a + b))) - lgamf(a)) - lgamf(b));\n  t += log((ans / a));\n  if ((t < -MAXLOGF)) {\n    t = 0.0;\n    if ((flag === 0)) {\n      mtherr(4);\n    }\n  } else {\n    t = exp(t);\n  }\n  if (bool(flag)) t = (1.0 - t);\n  return t;\n}"})),o.add(new z({dependencies:["floor","mtherr","float","log","exp","gammaf","hypergf"],constants:["MAXNUMF"],variables:[],signature:{name:"ivf",type:"float",arguments:[{name:"v",type:"float",index:0},{name:"x",type:"float",index:1}]},codeWebGL:"float ivf(float v, float x) {\n  int sign;\n  float t;\n  float ax;\n  t = floor(v);\n  if ((v < 0.0)) {\n    if ((t == v)) {\n      v = -v;\n      t = -t;\n    }\n  }\n  sign = 1;\n  if ((x < 0.0)) {\n    if ((t != v)) {\n      mtherr(1);\n      return 0.0;\n    }\n    if ((v != (2.0 * floor((v / 2.0))))) sign = -1;\n  }\n  if ((x == 0.0)) {\n    if ((v == 0.0)) return 1.0;\n    if ((v < 0.0)) {\n      mtherr(3);\n      return float(MAXNUMF);\n    } else return 0.0;\n  }\n  ax = ((x < float(0)) ? -x : x);\n  t = ((v * log((0.5 * ax))) - x);\n  t = ((float(sign) * exp(t)) / gammaf((v + 1.0)));\n  ax = (v + 0.5);\n  return (t * hypergf(ax, (2.0 * ax), (2.0 * x)));\n}",codeJS:"function ivf(v, x) {\n  let sign;\n  let t;\n  let ax;\n  t = floor(v);\n  if ((v < 0.0)) {\n    if ((t === v)) {\n      v = -v;\n      t = -t;\n    }\n  }\n  sign = 1;\n  if ((x < 0.0)) {\n    if ((t !== v)) {\n      mtherr(1);\n      return 0.0;\n    }\n    if ((v !== (2.0 * floor((v / 2.0))))) sign = -1;\n  }\n  if ((x === 0.0)) {\n    if ((v === 0.0)) return 1.0;\n    if ((v < 0.0)) {\n      mtherr(3);\n      return float(MAXNUMF);\n    } else return 0.0;\n  }\n  ax = ((x < float(0)) ? -x : x);\n  t = ((v * log((0.5 * ax))) - x);\n  t = ((float(sign) * exp(t)) / gammaf((v + 1.0)));\n  ax = (v + 0.5);\n  return (t * hypergf(ax, (2.0 * ax), (2.0 * x)));\n}"})),o.add(new v({name:"ndtrf_P",type:"float",value:new Float32Array([.02326819970068386,-.1387039388740657,.3687424674597105,-.5824733027278666,.6210004621745983,-.4944515323274145,.3404879937665872,-.2741127028184656,.5638259427386472]),valueString:"2.326819970068386E-002, -1.387039388740657E-001, 3.687424674597105E-001, -5.824733027278666E-001, 6.210004621745983E-001, -4.944515323274145E-001, 3.404879937665872E-001, -2.741127028184656E-001, 5.638259427386472E-001"})),o.add(new v({name:"ndtrf_R",type:"float",value:new Float32Array([-10.47766399936249,12.97719955372516,-7.495518717768503,2.921019019210786,-1.0152652792027,.4218463358204948,-.2820767439740514,.5641895067754075]),valueString:"-1.047766399936249E+001, 1.297719955372516E+001, -7.495518717768503E+000, 2.921019019210786E+000, -1.015265279202700E+000, 4.218463358204948E-001, -2.820767439740514E-001, 5.641895067754075E-001"})),o.add(new v({name:"ndtrf_T",type:"float",value:new Float32Array([7853861353153693e-20,-.0008010193625184903,.005188327685732524,-.02685381193529856,.1128358514861418,-.37612625824233,1.12837916572671]),valueString:"7.853861353153693E-005, -8.010193625184903E-004, 5.188327685732524E-003, -2.685381193529856E-002, 1.128358514861418E-001, -3.761262582423300E-001, 1.128379165726710E+000"})),o.add(new z({dependencies:["float","erfcf_recusive_erff","mtherr","exp","polevlf_8","polevlf_9"],constants:["MAXLOGF","ndtrf_R","ndtrf_P"],variables:[],signature:{name:"erfcf",type:"float",arguments:[{name:"aa",type:"float",index:0}]},codeWebGL:"float erfcf(float aa) {\n  float a;\n  float p;\n  float q;\n  float x;\n  float y;\n  float z;\n  a = aa;\n  x = ((a < float(0)) ? -a : a);\n  if ((x < 1.0)) return (1.0 - erfcf_recusive_erff(a));\n  z = (-a * a);\n  if ((z < -MAXLOGF)) {\n    mtherr(4);\n    if ((a < float(0))) return 2.0; else return 0.0;\n  }\n  z = exp(z);\n  q = (1.0 / x);\n  y = (q * q);\n  if ((x < 2.0)) {\n    p = polevlf_9(y, ndtrf_P, 8);\n  } else {\n    p = polevlf_8(y, ndtrf_R, 7);\n  }\n  y = ((z * q) * p);\n  if ((a < float(0))) y = (2.0 - y);\n  if ((y == 0.0)) {\n    mtherr(4);\n    if ((a < float(0))) return 2.0; else return 0.0;\n  }\n  return y;\n}",codeJS:"function erfcf(aa) {\n  let a;\n  let p;\n  let q;\n  let x;\n  let y;\n  let z;\n  a = aa;\n  x = ((a < float(0)) ? -a : a);\n  if ((x < 1.0)) return (1.0 - erfcf_recusive_erff(a));\n  z = (-a * a);\n  if ((z < -MAXLOGF)) {\n    mtherr(4);\n    if ((a < float(0))) return 2.0; else return 0.0;\n  }\n  z = exp(z);\n  q = (1.0 / x);\n  y = (q * q);\n  if ((x < 2.0)) {\n    p = polevlf_9(y, ndtrf_P, 8);\n  } else {\n    p = polevlf_8(y, ndtrf_R, 7);\n  }\n  y = ((z * q) * p);\n  if ((a < float(0))) y = (2.0 - y);\n  if ((y === 0.0)) {\n    mtherr(4);\n    if ((a < float(0))) return 2.0; else return 0.0;\n  }\n  return y;\n}"})),o.add(new z({dependencies:["float","erff_recusive_erfcf","polevlf_7"],constants:["ndtrf_T"],variables:[],signature:{name:"erff",type:"float",arguments:[{name:"xx",type:"float",index:0}]},codeWebGL:"float erff(float xx) {\n  float x;\n  float y;\n  float z;\n  x = xx;\n  if ((((x < float(0)) ? -x : x) > 1.0)) return (1.0 - erff_recusive_erfcf(x));\n  z = (x * x);\n  y = (x * polevlf_7(z, ndtrf_T, 6));\n  return y;\n}",codeJS:"function erff(xx) {\n  let x;\n  let y;\n  let z;\n  x = xx;\n  if ((((x < float(0)) ? -x : x) > 1.0)) return (1.0 - erff_recusive_erfcf(x));\n  z = (x * x);\n  y = (x * polevlf_7(z, ndtrf_T, 6));\n  return y;\n}"})),o.add(new z({dependencies:["float","polevlf_7"],constants:["ndtrf_T"],variables:[],signature:{name:"erfcf_recusive_erff",type:"float",arguments:[{name:"xx",type:"float",index:0}]},codeWebGL:"float erfcf_recusive_erff(float xx) {\n  float x;\n  float y;\n  float z;\n  x = xx;\n  if ((((x < float(0)) ? -x : x) > 1.0)) return (1.0 - NAN);\n  z = (x * x);\n  y = (x * polevlf_7(z, ndtrf_T, 6));\n  return y;\n}",codeJS:"function erfcf_recusive_erff(xx) {\n  let x;\n  let y;\n  let z;\n  x = xx;\n  if ((((x < float(0)) ? -x : x) > 1.0)) return (1.0 - NAN);\n  z = (x * x);\n  y = (x * polevlf_7(z, ndtrf_T, 6));\n  return y;\n}"})),o.add(new z({dependencies:["float","erfcf_recusive_erff","mtherr","exp","polevlf_8","polevlf_9"],constants:["MAXLOGF","ndtrf_R","ndtrf_P"],variables:[],signature:{name:"erff_recusive_erfcf",type:"float",arguments:[{name:"aa",type:"float",index:0}]},codeWebGL:"float erff_recusive_erfcf(float aa) {\n  float a;\n  float p;\n  float q;\n  float x;\n  float y;\n  float z;\n  a = aa;\n  x = ((a < float(0)) ? -a : a);\n  if ((x < 1.0)) return (1.0 - erfcf_recusive_erff(a));\n  z = (-a * a);\n  if ((z < -MAXLOGF)) {\n    mtherr(4);\n    if ((a < float(0))) return 2.0; else return 0.0;\n  }\n  z = exp(z);\n  q = (1.0 / x);\n  y = (q * q);\n  if ((x < 2.0)) {\n    p = polevlf_9(y, ndtrf_P, 8);\n  } else {\n    p = polevlf_8(y, ndtrf_R, 7);\n  }\n  y = ((z * q) * p);\n  if ((a < float(0))) y = (2.0 - y);\n  if ((y == 0.0)) {\n    mtherr(4);\n    if ((a < float(0))) return 2.0; else return 0.0;\n  }\n  return y;\n}",codeJS:"function erff_recusive_erfcf(aa) {\n  let a;\n  let p;\n  let q;\n  let x;\n  let y;\n  let z;\n  a = aa;\n  x = ((a < float(0)) ? -a : a);\n  if ((x < 1.0)) return (1.0 - erfcf_recusive_erff(a));\n  z = (-a * a);\n  if ((z < -MAXLOGF)) {\n    mtherr(4);\n    if ((a < float(0))) return 2.0; else return 0.0;\n  }\n  z = exp(z);\n  q = (1.0 / x);\n  y = (q * q);\n  if ((x < 2.0)) {\n    p = polevlf_9(y, ndtrf_P, 8);\n  } else {\n    p = polevlf_8(y, ndtrf_R, 7);\n  }\n  y = ((z * q) * p);\n  if ((a < float(0))) y = (2.0 - y);\n  if ((y === 0.0)) {\n    mtherr(4);\n    if ((a < float(0))) return 2.0; else return 0.0;\n  }\n  return y;\n}"})),o.add(new v({name:"psif_A",type:"float",value:new Float32Array([-.004166666666666667,.003968253968253968,-.008333333333333333,.08333333333333333]),valueString:"-4.16666666666666666667E-3, 3.96825396825396825397E-3, -8.33333333333333333333E-3, 8.33333333333333333333E-2"})),o.add(new z({dependencies:["floor","mtherr","tan","int","float","bool","polevlf_4","log"],constants:["MAXNUMF","PIF","psif_A"],variables:[],signature:{name:"psif",type:"float",arguments:[{name:"xx",type:"float",index:0}]},codeWebGL:"float psif(float xx) {\n  float p;\n  float q;\n  float nz;\n  float x;\n  float s;\n  float w;\n  float y;\n  float z;\n  int i;\n  int n;\n  int negative;\n  x = xx;\n  nz = 0.0;\n  negative = 0;\n  if ((x <= 0.0)) {\n    negative = 1;\n    q = x;\n    p = floor(q);\n    if ((p == q)) {\n      mtherr(2);\n      return MAXNUMF;\n    }\n    nz = (q - p);\n    if ((nz != 0.5)) {\n      if ((nz > 0.5)) {\n        p += 1.0;\n        nz = (q - p);\n      }\n      nz = (PIF / tan((PIF * nz)));\n    } else {\n      nz = 0.0;\n    }\n    x = (1.0 - x);\n  }\n  if (((x <= 10.0) && (x == floor(x)))) {\n    y = 0.0;\n    n = int(x);\n    i = 1;\n    for (int for_i = 0; (for_i < 1000); for_i++) {\n      if (!(i < n)) break;\n      w = float(i);\n      y += (1.0 / w);\n      i++;\n    }\n    \n    y -= 0.57721566490153286061;\n    if (bool(negative)) {\n      y -= nz;\n    }\n    return y;\n  }\n  s = x;\n  w = 0.0;\n  for (int while_i = 0; (while_i < 1000); while_i++) {\n    if (!(s < 10.0)) break;\n    w += (1.0 / s);\n    s += 1.0;\n  }\n  \n  if ((s < 1.0e8)) {\n    z = (1.0 / (s * s));\n    y = (z * polevlf_4(z, psif_A, 3));\n  } else y = 0.0;\n  y = (((log(s) - (0.5 / s)) - y) - w);\n  if (bool(negative)) {\n    y -= nz;\n  }\n  return y;\n}",codeJS:"function psif(xx) {\n  let p;\n  let q;\n  let nz;\n  let x;\n  let s;\n  let w;\n  let y;\n  let z;\n  let i;\n  let n;\n  let negative;\n  x = xx;\n  nz = 0.0;\n  negative = 0;\n  if ((x <= 0.0)) {\n    negative = 1;\n    q = x;\n    p = floor(q);\n    if ((p === q)) {\n      mtherr(2);\n      return MAXNUMF;\n    }\n    nz = (q - p);\n    if ((nz !== 0.5)) {\n      if ((nz > 0.5)) {\n        p += 1.0;\n        nz = (q - p);\n      }\n      nz = (PIF / tan((PIF * nz)));\n    } else {\n      nz = 0.0;\n    }\n    x = (1.0 - x);\n  }\n  if (((x <= 10.0) && (x === floor(x)))) {\n    y = 0.0;\n    n = int(x);\n    i = 1;\n    for (let for_i = 0; (for_i < 1000); for_i++) {\n      if (!(i < n)) break;\n      w = float(i);\n      y += (1.0 / w);\n      i++;\n    }\n    \n    y -= 0.57721566490153286061;\n    if (bool(negative)) {\n      y -= nz;\n    }\n    return y;\n  }\n  s = x;\n  w = 0.0;\n  for (let while_i = 0; (while_i < 1000); while_i++) {\n    if (!(s < 10.0)) break;\n    w += (1.0 / s);\n    s += 1.0;\n  }\n  \n  if ((s < 1.0e8)) {\n    z = (1.0 / (s * s));\n    y = (z * polevlf_4(z, psif_A, 3));\n  } else y = 0.0;\n  y = (((log(s) - (0.5 / s)) - y) - w);\n  if (bool(negative)) {\n    y -= nz;\n  }\n  return y;\n}"})),o.add(new v({name:"zetaf_A",type:"float",value:new Float32Array([12,-720,30240,-1209600,47900160,-1892437580.3183792,74724249600,-2950130727918.164,116467828143500.67,-4597978722407473,0x284e46fd8153bc0,-0x637355552018c800]),valueString:"12.0, -720.0, 30240.0, -1209600.0, 47900160.0, -1.8924375803183791606e9, 7.47242496e10, -2.950130727918164224e12, 1.1646782814350067249e14, -4.5979787224074726105e15, 1.8152105401943546773e17, -7.1661652561756670113e18"})),o.add(new z({dependencies:["mtherr","pow","float"],constants:["MAXNUMF","MACHEPF","zetaf_A"],variables:[],signature:{name:"zetaf",type:"float",arguments:[{name:"xx",type:"float",index:0},{name:"qq",type:"float",index:1}]},codeWebGL:"float zetaf(float xx, float qq) {\n  int i;\n  float x;\n  float q;\n  float a;\n  float b;\n  float k;\n  float s;\n  float w;\n  float t;\n  x = xx;\n  q = qq;\n  if ((x == 1.0)) return MAXNUMF;\n  if ((x < 1.0)) {\n    mtherr(1);\n    return 0.0;\n  }\n  w = 9.0;\n  s = pow(q, -x);\n  a = q;\n  for (int i = 0; (i < 9); i++) {\n    a += 1.0;\n    b = pow(a, -x);\n    s += b;\n    if (((b / s) < MACHEPF)) {\n      return s;\n    }\n  }\n  \n  w = a;\n  s += ((b * w) / (x - 1.0));\n  s -= (0.5 * b);\n  a = 1.0;\n  k = 0.0;\n  for (int i = 0; (i < 12); i++) {\n    a *= (x + k);\n    b /= w;\n    t = ((a * b) / float(zetaf_A[i]));\n    s = (s + t);\n    t = (((t / s) < float(0)) ? -(t / s) : (t / s));\n    if ((t < MACHEPF)) {\n      return s;\n    }\n    k += 1.0;\n    a *= (x + k);\n    b /= w;\n    k += 1.0;\n  }\n  \n  return s;\n}",codeJS:"function zetaf(xx, qq) {\n  let i;\n  let x;\n  let q;\n  let a;\n  let b;\n  let k;\n  let s;\n  let w;\n  let t;\n  x = xx;\n  q = qq;\n  if ((x === 1.0)) return MAXNUMF;\n  if ((x < 1.0)) {\n    mtherr(1);\n    return 0.0;\n  }\n  w = 9.0;\n  s = pow(q, -x);\n  a = q;\n  for (let i = 0; (i < 9); i++) {\n    a += 1.0;\n    b = pow(a, -x);\n    s += b;\n    if (((b / s) < MACHEPF)) {\n      return s;\n    }\n  }\n  \n  w = a;\n  s += ((b * w) / (x - 1.0));\n  s -= (0.5 * b);\n  a = 1.0;\n  k = 0.0;\n  for (let i = 0; (i < 12); i++) {\n    a *= (x + k);\n    b /= w;\n    t = ((a * b) / float(zetaf_A[i]));\n    s = (s + t);\n    t = (((t / s) < float(0)) ? -(t / s) : (t / s));\n    if ((t < MACHEPF)) {\n      return s;\n    }\n    k += 1.0;\n    a *= (x + k);\n    b /= w;\n    k += 1.0;\n  }\n  \n  return s;\n}"})),o.add(new z({signature:{name:"float",type:"float",arguments:[{name:"value",type:"T",index:0}]},dependencies:[],constants:[],variables:[],codeWebGL:null,codeJS:"function float(value) { return value; }"})),o.add(new z({dependencies:[],constants:[],variables:[],signature:{name:"int",type:"int",arguments:[{name:"value",type:"T",index:0}]},codeWebGL:null,codeJS:"function int(value) { return value | 0; }"})),o.add(new z({signature:{name:"bool",type:"bool",arguments:[{name:"value",type:"T",index:0}]},dependencies:[],constants:[],variables:[],codeWebGL:null,codeJS:"function bool(value) { return (value !== 0); }"}));try{for(var M=r(["sin","cos","tan","asin","acos","atan","exp","log","log2","sqrt","floor","ceil"]),w=M.next();!w.done;w=M.next()){var F=w.value;o.add(new z({signature:{name:F,type:"T",arguments:[{name:"value",type:"T",index:0}]},dependencies:[],constants:[],variables:[],codeWebGL:null,codeJS:"function "+F+"(value) { return Math."+F+"(value); }"}))}}catch(n){d={error:n}}finally{try{w&&!w.done&&(y=M.return)&&y.call(M)}finally{if(d)throw d.error}}o.add(new z({signature:{name:"pow",type:"float",arguments:[{name:"x",type:"float",index:0},{name:"n",type:"float",index:0}]},dependencies:[],constants:[],variables:[],codeWebGL:null,codeJS:"function pow(x, n) { return Math.pow(x, n); }"})),o.add(new z({signature:{name:"atan2",type:"float",arguments:[{name:"x",type:"float",index:0},{name:"y",type:"float",index:0}]},dependencies:[],constants:[],variables:[],codeWebGL:"atan2(float x, float y) { return atan(x, y); }",codeJS:"function atan2(x, y) { return Math.atan2(x, y); }"})),o.add(new z({signature:{name:"exp2",type:"float",arguments:[{name:"value",type:"float",index:0}]},dependencies:[],constants:[],variables:[],codeWebGL:null,codeJS:"function exp2(value) { return Math.pow(2, value); }"})),o.add(new(function(n){function e(){return n.call(this,{signature:{name:"is_odd",type:"int",arguments:[{name:"value",type:"int",index:0}]},dependencies:[],constants:[],variables:[],codeWebGL:"// replaced by exportAsWebGL",codeJS:"function is_odd(value) { return value & 1; }"})||this}return t(e,n),e.prototype.exportAsWebGL=function(n){return 2===n?"int is_odd(int value) { return value & 1; }":"int is_odd(int value) {\n                return int(mod(float(value), 2.0));\n            }"},e}(z))),o.add(new z({signature:{name:"mtherr",type:"void",arguments:[{name:"code",type:"int",index:0}]},dependencies:[],constants:[],variables:[],codeWebGL:"void mtherr(int code) { }",codeJS:"function mtherr(code) { }"}));for(var E=1;E<=20;E++)o.add(new z({signature:{name:"chbevlf_"+E,type:"float",arguments:[{name:"x",type:"float",index:0},{name:"array",type:"float["+E+"]",index:2},{name:"n",type:"int",index:2}]},dependencies:[],constants:[],variables:[],codeWebGL:"float chbevlf_"+E+"(float x, float array["+E+"], int n) {\n            float b0 = array[0];\n            float b1 = 0.0;\n            float b2;\n            for (int i = 1; (i < "+E+"); i++) {\n                b2 = b1;\n                b1 = b0;\n                b0 = (((x * b1) - b2) + array[i]);\n            }\n\n            return (0.5 * (b0 - b2));\n        }",codeJS:"function chbevlf_"+E+"(x, array, n) {\n            let b0 = array[0];\n            let b1 = 0.0;\n            let b2;\n            for (let i = 1; (i < "+E+"); i++) {\n                b2 = b1;\n                b1 = b0;\n                b0 = (((x * b1) - b2) + array[i]);\n            }\n\n            return (0.5 * (b0 - b2));\n        }"})),o.add(new z({signature:{name:"polevlf_"+E,type:"float",arguments:[{name:"xx",type:"float",index:0},{name:"coef",type:"float["+E+"]",index:2},{name:"N",type:"int",index:2}]},dependencies:[],constants:[],variables:[],codeWebGL:"float polevlf_"+E+"(float xx, float coef["+E+"], int N) {\n            float ans = coef[0];\n            for (int i = 1; (i <= "+(E-1)+"); i++) {\n                ans = ((ans * xx) + coef[i]);\n            }\n\n            return ans;\n        }",codeJS:"function polevlf_"+E+"(xx, coef, N) {\n            let ans = coef[0];\n            for (let i = 1; (i <= "+(E-1)+"); i++) {\n                ans = ((ans * xx) + coef[i]);\n            }\n\n            return ans;\n        }"})),o.add(new z({signature:{name:"p1evlf_"+E,type:"float",arguments:[{name:"xx",type:"float",index:0},{name:"coef",type:"float["+E+"]",index:2},{name:"N",type:"int",index:2}]},dependencies:[],constants:[],variables:[],codeWebGL:"float p1evlf_"+E+"(float xx, float coef["+E+"], int N) {\n            float ans = (xx + coef[0]);\n            for (int i = 1; (i < "+E+"); i++) {\n                ans = ((ans * xx) + coef[i]);\n            }\n\n            return ans;\n        }",codeJS:"function p1evlf_"+E+"(xx, coef, N) {\n            let ans = (xx + coef[0]);\n            for (let i = 1; (i < "+E+"); i++) {\n                ans = ((ans * xx) + coef[i]);\n            }\n\n            return ans;\n        }"}));function P(n,a,t){return e.customGrad(function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r=e.pop(),f=e;return{value:n(f,r),gradFunc:a}}).apply(void 0,l(t))}function S(n,a){var t=x.apply(void 0,l(a));return n.map(function(n,r){var f=a[r];if(null===n)return e.zeros(f);var l=e.backend_util.getReductionAxes(f,t);return l.length>0&&(n=n.sum(l).reshape(f)),n})}function C(n,a,t){var r=n instanceof e.Tensor?n.dtype:e.util.inferDtype(n);if("float32"!==r)throw new Error("Argument '"+a+"' passed to '"+t+"' must be a Tensor or TensorLike, with float32 as the dtype but got dtype '"+r+"'");return n instanceof e.Tensor?n:(e.util.isTypedArray(n)||Array.isArray(n)||(n=[n]),e.Tensor.make(function(n){if(e.util.isTypedArray(n))return[n.length];if(!Array.isArray(n))return[];var a=[],t=n;for(;Array.isArray(t)||e.util.isTypedArray(t);)a.push(t.length),t=t[0];return a}(n),{values:e.util.toTypedArray(n,"float32",e.ENV.getBool("DEBUG"))},"float32"))}function N(n){var e=g("i0f");return P(function(n,a){var t=f(n,1)[0];return a([t]),e.runUnary(t)},function(n,e){var a=f(e,1)[0];return[n.mul(L(a))]},[C(n,"x","i0")])}function L(n){var e=g("i1f");return P(function(n,a){var t=f(n,1)[0];return a([t]),e.runUnary(t)},function(n,e){var a=f(e,1)[0];return[n.mul(N(a).add(H(2,a)).mul(.5))]},[C(n,"x","i1")])}function H(n,a){if(1===n)return L(a);var t=g("ivf");return P(function(a,r){var l=f(a,1)[0];return r([l]),t.run(e.scalar(n),l)},function(e,a){var t=f(a,1)[0];return[e.mul(H(n-1,t).add(H(n+1,t)).mul(.5))]},[a])}function G(n){var a=g("i0ef");return P(function(n,e){var t=f(n,1)[0];return e([t]),a.runUnary(t)},function(n,a){var t=f(a,1)[0];return[n.mul(G(e.abs(t)).sub(X(e.abs(t))).mul(e.sign(t)).neg())]},[C(n,"x","i0e")])}function X(n){var a=g("i1ef");return P(function(n,e){var t=f(n,1)[0];return e([t]),a.runUnary(t)},function(n,a){var t=f(a,1)[0];return[n.mul(G(e.abs(t)).sub(X(e.abs(t)).mul(2)).add(U(2,e.abs(t))).mul(.5))]},[C(n,"x","i1e")])}function U(n,a){if(1===n)return X(a);var t=g("ivf");return P(function(a,r){var l=f(a,1)[0];return r([l]),t.run(e.scalar(n),l).mul(e.exp(e.abs(l).neg()))},function(a,t){var r=f(t,1)[0],l=n%2?e.sign(r).mul(.5):.5;return[a.mul(U(n-1,e.abs(r)).sub(U(n,e.abs(r)).mul(2)).add(U(n+1,e.abs(r))).mul(l))]},[a])}function W(n){var e=g("lgamf");return P(function(n,a){var t=f(n,1)[0];return a([t]),e.runUnary(t)},function(n,e){var a=f(e,1)[0];return[n.mul(J(a))]},[C(n,"x","lgamma")])}function J(n){var e=g("psif");return P(function(n,a){var t=f(n,1)[0];return a([t]),e.runUnary(t)},function(n,e){var a=f(e,1)[0];return[n.mul(I(1,a))]},[C(n,"x","digamma")])}function I(n,a){var t=g("gammaf"),r=g("zetaf");return P(function(a,l){var o=f(a,1)[0];l([o]);var i=e.scalar(n+1);return e.pow(-1,i).mul(t.runUnary(i)).mul(r.run(i,o))},function(e,a){var t=f(a,1)[0];return[e.mul(I(n+1,t))]},[a])}function O(n){var e=g("gammaf");return P(function(n,a){var t=f(n,1)[0];return a([t]),e.runUnary(t)},function(n,e){var a=f(e,1)[0];return[n.mul(O(a).mul(J(a)))]},[n])}function R(n,e){var a=g("betaf");return P(function(n,e){var t=f(n,2),r=t[0],l=t[1];return e([r,l]),a.run(r,l)},function(n,e){var a=f(e,2),t=a[0],r=a[1],l=J(t.add(r)),o=R(t,r);return S([n.mul(J(t).sub(l).mul(o)),n.mul(J(r).sub(l).mul(o))],[t.shape,r.shape])},[n,e])}n.betainc=function(n,e,a){var t=g("incbetf");return P(function(n,e){var a=f(n,3),r=a[0],l=a[1],o=a[2];return e([r,l,o]),t.run(r,l,o)},function(n,e){var a=f(e,3),t=a[0],r=a[1],l=a[2];return S([null,null,n.mul(l.pow(t.sub(1)).mul(l.sub(1).neg().pow(r.sub(1))).div(R(t,r)))],[t.shape,r.shape,l.shape])},[C(n,"a","betainc"),C(e,"b","betainc"),C(a,"x","betainc")])},n.digamma=J,n.erf=function(n){var e=g("erff");return P(function(n,a){var t=f(n,1)[0];return a([t]),e.runUnary(t)},function(n,e){var a=f(e,1)[0];return[n.mul(a.square().neg().exp().mul(2/Math.sqrt(Math.PI)))]},[C(n,"x","erf")])},n.erfc=function(n){var e=g("erfcf");return P(function(n,a){var t=f(n,1)[0];return a([t]),e.runUnary(t)},function(n,e){var a=f(e,1)[0];return[n.mul(a.square().neg().exp().mul(-2/Math.sqrt(Math.PI)))]},[C(n,"x","erf")])},n.i0=N,n.i0e=G,n.i1=L,n.i1e=X,n.igamma=function(n,e){var a=g("igamf");return P(function(n,e){var t=f(n,2),r=t[0],l=t[1];return e([r,l]),a.run(r,l)},function(n,e){var a=f(e,2),t=a[0],r=a[1];return S([null,n.mul(r.neg().exp().mul(r.pow(t.sub(1))).div(O(t)))],[t.shape,r.shape])},[C(n,"a","igamma"),C(e,"x","igamma")])},n.igammac=function(n,e){var a=g("igamcf");return P(function(n,e){var t=f(n,2),r=t[0],l=t[1];return e([r,l]),a.run(r,l)},function(n,e){var a=f(e,2),t=a[0],r=a[1];return S([null,n.mul(r.neg().exp().mul(r.pow(t.sub(1))).div(O(t)).neg())],[t.shape,r.shape])},[C(n,"a","igammac"),C(e,"x","igammac")])},n.lbeta=function(n){if(0===(n=C(n,"x","lbeta")).rank)throw new TypeError("x Tensor in lbeta must have rank > 0, has rank = 0");return n.shape[n.shape.length-1]<=0?e.ones(n.shape.slice(0,-1)):W(n).sum(-1).sub(W(n.sum(-1)))},n.lgamma=W,n.polygamma=function n(a,t){var r=g("psif"),l=g("gammaf"),o=g("zetaf");return P(function(n,a){var t=f(n,2),i=t[0],x=t[1];a([i,x]);var s=r.runUnary(x).mul(e.onesLike(i)),m=i.add(1),u=e.pow(-1,m).mul(l.runUnary(m)).mul(o.run(m,x));return e.where(i.add(e.zerosLike(x)).equal(0),s,u)},function(e,a){var t=f(a,2),r=t[0],l=t[1];return S([null,e.mul(n(r.add(1),l))],[r.shape,l.shape])},[C(a,"m","polygamma"),C(t,"x","polygamma")])},n.zeta=function n(e,a){var t=g("zetaf");return P(function(n,e){var a=f(n,2),r=a[0],l=a[1];return e([r,l]),t.run(r,l)},function(e,a){var t=f(a,2),r=t[0],l=t[1];return S([null,e.mul(n(r.add(1),l).mul(r).neg())],[r.shape,l.shape])},[C(e,"x","zeta"),C(a,"q","zeta")])},Object.defineProperty(n,"__esModule",{value:!0})});
//# sourceMappingURL=tf-math-special.min.js.map
